<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>VikingWarlock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="VikingWarlock&#39;s daily life and develop experience">
<meta property="og:type" content="website">
<meta property="og:title" content="VikingWarlock">
<meta property="og:url" content="http://vkwk.site/page/6/index.html">
<meta property="og:site_name" content="VikingWarlock">
<meta property="og:description" content="VikingWarlock&#39;s daily life and develop experience">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Viking Warlock">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="VikingWarlock" type="application/atom+xml">
  
  
    <link rel="icon" href="/avatar.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">VikingWarlock</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://vkwk.site"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-bluetooth-permission" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/programming/20161230-bluetooth-permission.html" class="article-date">
  <time datetime="2016-12-30T01:40:57.000Z" itemprop="datePublished">2016-12-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/programming/20161230-bluetooth-permission.html">蛋疼的GATT权限</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>定位水壶架App的iOS端已经完成了80%,在考完矩阵之前,只要把android端的网络和蓝牙交互做完,就可以没什么太大的压力咯.</p>
<p>然而,在搞android端的时候,还是遇到了很多很多问题的.</p>
<h2 id="第一坑"><a href="#第一坑" class="headerlink" title="第一坑"></a>第一坑</h2><p>几天前,当我把iOS端蓝牙配对的代码,翻译为Java版本之后,本来想,肯定会轻轻松松,正正常常的运行了.</p>
<p>但是,在连接上定位器之后,总是会卡在<code>搜索服务</code>或者<code>写入xxx</code>这个阶段,然后就断线了.</p>
<p>当时,我觉得,可能是一些小问题,可能是我写漏了什么东西,所以就卡住了.</p>
<p>也怀疑过是Google的亲儿子Nexus蓝牙硬件不给力~</p>
<p>然后就痛苦的去复习了几天<code>矩阵理论</code>…………</p>
<p>但是,就在两个小时之前,我一步一步调试的时候,发现了一个奇怪的现象.</p>
<pre><code>public void onServicesDiscovered(BluetoothGatt gatt, int status);
</code></pre><p>在<code>BluetoothGattCallback</code>中,搜索到service的时候,竟然没有我们自己的service!</p>
<p>所以for循环就那么做完了……什么service都没有找到,最后就被关闭连接了.</p>
<h4 id="这时候-我开始怀疑人生了"><a href="#这时候-我开始怀疑人生了" class="headerlink" title="这时候,我开始怀疑人生了"></a>这时候,我开始怀疑人生了</h4><p>难道说,这蓝牙是为iOS设计的!?</p>
<p>赶紧整了一个锤子过来测测.发现锤子是可以找到所有的service的……</p>
<p>难道说,这蓝牙不是为Google设计的!?</p>
<p>这时候,我突然想到了一个问题.和之前几天的实验,可能有点儿关系.</p>
<h5 id="很久很久的几天前"><a href="#很久很久的几天前" class="headerlink" title="很久很久的几天前"></a>很久很久的几天前</h5><p>添哥找我说,蓝牙可以设置一个加密密钥,这样子传输数据,就是加密的了.(虽然说,蓝牙和WiFi一样,是要<code>连接</code>之后才能通信的,但是,无线嘛,肯定是要被窃听的)</p>
<p>于是我们就试验了一下,但是蓝牙加密之后,需要手动在手机上点击<code>配对</code>按钮,才可以进行加密通信.</p>
<p>由于android端,这个<code>配对</code>不是特别的明显,不像iOS那么粗暴地弹出来.所以我们最后没有使用这个方案.</p>
<h5 id="这里还可以顺便说说加密"><a href="#这里还可以顺便说说加密" class="headerlink" title="这里还可以顺便说说加密"></a>这里还可以顺便说说加密</h5><p>小时候,以为加密的意思就是,给数据加了一把锁.只要用密码把锁打开了,就可以访问数据了.(真单纯)</p>
<p>原来,加密是把数据都给翻译了一遍.即使知道加密解密的算法,使用错误的密钥,可以得到数据,但是这数据,肯定是错的.</p>
<p>当蓝牙加密通信的时候,会分配一个密钥.咱们配对蓝牙鼠标,蓝牙键盘的时候,也常常看到,需要输入个什么pin码,才能配对.一旦这配对了,之后通信就是加密的了.</p>
<p>(假设蓝牙键盘不用配对,不加密通信……)那就是无线的按键记录器啊!</p>
<h5 id="总而言之"><a href="#总而言之" class="headerlink" title="总而言之"></a>总而言之</h5><p>这搜索不出我们需要的service就是这个配对的<code>锅</code>,当我进入系统蓝牙设置,把这个设备的配对给取消了之后,就正常了~.~</p>
<h2 id="第二坑的Context"><a href="#第二坑的Context" class="headerlink" title="第二坑的Context"></a>第二坑的Context</h2><p>BLE的GATT的Characteristic有权限控制.</p>
<p>大概就是Read,Write,WriteWithoutResponse,Notify这四种常见权限.</p>
<p>他们用一个8位的flag来控制.因为不是重点,所以懒得讲了.</p>
<h2 id="第二坑"><a href="#第二坑" class="headerlink" title="第二坑"></a>第二坑</h2><p>在我解决了Service Discover的问题了之后,我觉得,这下一定可以顺利地跑下去了!</p>
<p>结果卡在了一个写入之后的读取上…</p>
<p>本来,在写入一个数据之后,需要去读取一个反馈的.但是不知道为什么,没有去读取这个数据.</p>
<p>仔细阅读Monitor里面的log.可以发现,之前的读取,都会调用系统的readCharacteristic()函数,而这一次的读取却没有读取,这是为啥子嘞?</p>
<p>权限!</p>
<p>我们有一个Characteristic在写入之后,需要读取反馈.所以需要Read的权限.</p>
<p>然而,在这个Characteristic没有Read的权限的情况下,iOS端竟然还是可以正确的读取到数据!</p>
<p>而Android直接忽略的readCharacteristic()这个函数调用……</p>
<p>虽然说,这硬件是我们自己设计的,讲道理的话,在连接设备之后,并不需要去检查各种权限的.<code>(除非这个硬件是被山寨的)</code></p>
<p>但是,加上一个权限验证的话,或许可以提高一些软件的稳健性呢?说不定可以让这个系统可以在遇到山寨货的情况下,可以继续正常的工作下去呢~</p>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>2016马上要结束了,每年都能更加深入的了解一些蓝牙,真的是好刺激!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/programming/20161230-bluetooth-permission.html" data-id="ckl153waw002yzxijj8q3fn2j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ble/" rel="tag">蓝牙</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-first-time-volley" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/programming/20161225-first-time-volley.html" class="article-date">
  <time datetime="2016-12-25T02:30:47.000Z" itemprop="datePublished">2016-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/programming/20161225-first-time-volley.html">初用Volley</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>水壶架iOS端终于撸完了</p>
<p>由于我Android的界面写的烂的一逼,所以只能拜托<a href="https://github.com/wuapnjie" target="_blank" rel="noopener">xiaopo</a>来帮我撸界面了.</p>
<p>首要目标是干掉蓝牙类,不过蓝牙绑定设备的时候会需要网络请求.</p>
<p>那就顺便把网络也给撸掉吧~</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>1.需要一个请求队列</p>
<pre><code>RequestQueue mQueue = Volley.newRequestQueue(context);
</code></pre><p>2.好了直接撸请求吧</p>
<p>Form-Data这么搞</p>
<pre><code>StringRequest stringRequest = new StringRequest(&quot;一个URL&quot;,new Response.Listener&lt;String&gt;() {
        @Override
        public void onResponse(String response) {
               Log.d(&quot;Network OK&quot;, response);
        }
        }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
               Log.e(&quot;Network Fail&quot;, error.getMessage(), error);
        }
});
</code></pre><p>JSON这么搞</p>
<pre><code>JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(&quot;http://m.weather.com.cn/data/101010100.html&quot;, null,
    new Response.Listener&lt;JSONObject&gt;() {
        @Override
        public void onResponse(JSONObject response) {
            Log.d(&quot;Network OK&quot;, response.toString());
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
            Log.e(&quot;Network Fail&quot;, error.getMessage(), error);
        }
    });
</code></pre><h3 id="Q1-请求是form-data-响应是json"><a href="#Q1-请求是form-data-响应是json" class="headerlink" title="Q1 请求是form-data 响应是json"></a>Q1 请求是form-data 响应是json</h3><p>不过这里遇到了一个问题.</p>
<p>我们服务器大佬坑我,请求只能解析Form-Data的,返回的响应是Json</p>
<p>于是只能手动转换了</p>
<pre><code>private static StringRequest FormDataRequest(String url, int method, Map parameter, VKNetworkSucceedBlock succeedBlock, VKNetworkFailBlock failBlock) {
    StringRequest request=new StringRequest(method, url, new Response.Listener&lt;String&gt;() {

        @Override
        public void onResponse(String response) {
            try {
                JSONObject jsonResponse = new JSONObject(response);
                if (jsonResponse.getInt(&quot;status&quot;) == 10086) {
                    //认证失败
                    failBlock.requestFail(new Exception(&quot;SessionExpired&quot;));
                } else {
                    succeedBlock.getResponse(jsonResponse);
                }
            } catch (JSONException e) {
                e.printStackTrace();
                failBlock.requestFail(e);
            }
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
            if (error.networkResponse.statusCode == 10000) {
                //认证失败
                failBlock.requestFail(new Exception(&quot;SessionExpired&quot;));
            } else
                failBlock.requestFail(error);
        }}){
        @Override
        protected Map&lt;String, String&gt; getParams() throws AuthFailureError {
            return parameter;
        }
    };
    queue().add(request);
    return request;
}
</code></pre><p>用JSONObject自带的牛逼的初始化方法来解析响应</p>
<h3 id="Q2-cookie"><a href="#Q2-cookie" class="headerlink" title="Q2 cookie"></a>Q2 cookie</h3><p>好不容易,把网络请求跑通了.</p>
<p>才发现,一个劲的403.</p>
<p>原来,Volley本身不处理Cookie的!!</p>
<p><code>啊席巴</code></p>
<p>于是就要手动处理</p>
<pre><code>private static StringRequest FormDataRequest(String url, int method, Map parameter, VKNetworkSucceedBlock succeedBlock, VKNetworkFailBlock failBlock) {
    StringRequest request=new StringRequest(method, url, new Response.Listener&lt;String&gt;() {

        @Override
        public void onResponse(String response) {
           //这些你都看过了
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
            //这些你都看过了
            }){
        @Override
        protected Map&lt;String, String&gt; getParams() throws AuthFailureError {
            return parameter;
        }

        @Override
        public Map&lt;String, String&gt; getHeaders() throws AuthFailureError {
            Map&lt;String,String&gt; header=super.getHeaders();
            String cookie=getCookie();
            if (cookie!=null){
                header.put(&quot;Set-Cookie&quot;,cookie);
                //手动从把Cookie放到Header中
            }
            return header;
        }

        @Override
        protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) {
            refreshCookie(response.headers);
                //手动从Response的Header中获取Cookie
            return super.parseNetworkResponse(response);
        }
    };
    queue().add(request);
    return request;
}
</code></pre><p>这其中的Cookie持久化什么的,就不说了.它不是重点.</p>
<p>而重点是……</p>
<h3 id="Final-我放弃了"><a href="#Final-我放弃了" class="headerlink" title="Final 我放弃了"></a>Final 我放弃了</h3><p>当Response的Header中有多个<code>Set-Cookie</code>字段时,只会被解析出来一个!</p>
<p>如果需要把所有的Cookie都拿出来的话,需要修改Volley源码!</p>
<p>然而,我使用Gradle来添加Volley工程的,所以,你逗我吗!</p>
<p>于是乎,我就放弃了.</p>
<h3 id="姜还是老的辣"><a href="#姜还是老的辣" class="headerlink" title="姜还是老的辣"></a>姜还是老的辣</h3><p>大三的时候做精益防伪,使用了<a href="https://github.com/loopj/android-async-http" target="_blank" rel="noopener">Android-Async-Http</a></p>
<p>这个很牛逼,功能很强大,还自动缓存了Cookie,真是替我省心.</p>
<p>还好前面撸接口的时候,封装的比较好,所以没有改动太多的东西.</p>
<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>封装了两个基本网络操作函数</p>
<pre><code>public static void getMethodFormData(String url, Map&lt;String,String&gt; parameter, VKNetworkSucceedBlock succeedBlock, VKNetworkFailBlock failBlock){
    getViaLoopj(url,parameter,succeedBlock,failBlock);
}

public static void postMethodFormData(String url, Map&lt;String,String&gt; parameter, VKNetworkSucceedBlock succeedBlock, VKNetworkFailBlock failBlock){
    postViaLoopj(url,parameter,succeedBlock,failBlock);
}
</code></pre><p>再来一发Android-Async-Http的实例(封装过了)</p>
<pre><code>public static void postViaLoopj(String url, Map&lt;String,String&gt; params,VKNetworkSucceedBlock succeedBlock,VKNetworkFailBlock failBlock) {
    client.post(url, new RequestParams(params), new JsonHttpResponseHandler(){
        @Override
        public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
            if (statusCode==403){
                failBlock.requestFail(new Exception(&quot;SessionExpired&quot;));
            }else
            {
                succeedBlock.getResponse(response);
            }
        }
        @Override
        public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) {
            super.onFailure(statusCode, headers, throwable, errorResponse);
            if (statusCode==403){
                failBlock.requestFail(new Exception(&quot;SessionExpired&quot;));
            }else{
                failBlock.requestFail(new Exception(errorResponse.toString()));
            }
        }
        @Override
        public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
            super.onFailure(statusCode, headers, responseString, throwable);
            if (statusCode==403){
                failBlock.requestFail(new Exception(&quot;SessionExpired&quot;));
            }else
                failBlock.requestFail(new Exception(responseString));
        }
    });
}
</code></pre><p>定义了两个interface</p>
<pre><code>public interface VKNetworkSucceedBlock {
    void getResponse(JSONObject responseObject);
}

public interface VKNetworkFailBlock {
    void requestFail(Exception error);
}
</code></pre><p>于是乎做网络请求,就方便的很了</p>
<pre><code>public static void mLogin(String email, String verify, boolean isChina, NetworkUtils.VKNetworkSucceedBlock succeed, NetworkUtils.VKNetworkFailBlock fail){
    HashMap&lt;String,String&gt; map=new HashMap&lt;String, String&gt;(){{
            put("hhh","123@163.com");
            put("jjj","3434");
            put("kkk",String.valueOf(1));
        }};
      NetworkUtils.postMethodFormData(UrlManager.URL_Login,map,succeed,fail);
}
</code></pre><p>最后网络的效果,就留到具体调用他的类去实现吧.</p>
<p>所以,封装了一遍就是好<code>瞧把你能耐的</code>,更换网络框架,不需要跑到每个Activity啊,Class里面去改.</p>
<p>response也是一套,</p>
<p>顶层完全不用去关注,底层的网络是如何实现的.(好像<code>段老师</code>还是<code>郝老师</code>这么说过)</p>
<h4 id="当然我相信-来看这篇文章的大佬们-肯定早就知道这个了"><a href="#当然我相信-来看这篇文章的大佬们-肯定早就知道这个了" class="headerlink" title="当然我相信,来看这篇文章的大佬们,肯定早就知道这个了"></a>当然我相信,来看这篇文章的大佬们,肯定早就知道这个了</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/programming/20161225-first-time-volley.html" data-id="ckl153wb7003nzxijojj3k7ml" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-use-status-base-to-handle-complex-operation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/programming/20161221-use-status-base-to-handle-complex-operation.html" class="article-date">
  <time datetime="2016-12-21T03:55:11.000Z" itemprop="datePublished">2016-12-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/programming/20161221-use-status-base-to-handle-complex-operation.html">用状态机来实现复杂操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>这次新产品的蓝牙绑定过程有点儿复杂</p>
<p>与炫轮作比较</p>
<p>炫轮只有一个characteristic,不同的操作之间没有顺序关系,都是并列的</p>
<p>新产品有多个characteristic,每个characteristic有不同的意义和不同的指令,每个操作都有先后顺序</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>突然想起来,本科的微处理器,还是数字电路课,讲过状态机这个玩意儿.我觉得,可以拿来搞一搞.这样清晰明了,可以省去很多中间变量.</p>
<p>比如</p>
<pre><code>BOOL isConnecting;
BOOL isDiscovering;
BOOL didWriteXXX;
BOOL didReadXXX;
.....
</code></pre><p>使用了状态机,并且规定好了状态转移的条件,那么,整个<code>系统</code>就一定在这个状态列表中滚.不会出现位置状态,导致程序跑飞.</p>
<p>因为从状态A–&gt;状态B,只有当前条件是xxxx的时候才会实现.这时候不用再去管其他的变量,其他的事件.</p>
<p>使用了状态机,可以轻松地对已有逻辑进行扩充,因为只要拿出,状态转移图来.找到需要添加的地方,就能确定在代码中,有多少地方需要修改,如此一来,就不用在需要该需求的时候,重新阅读已有代码了!</p>
<p>使用了状态机,一般只需要一个记录状态的变量就够了,而且重写这个变量的Setter方法,还可以方便做一些其他的事情:</p>
<pre><code>-(void)setStage:(VKLocatorPairState)stage{
    NSLog(@&quot;pairing status %@&quot;,[PublicHelper localizedStringForPairStatus:stage]);
    //发送通知
    //如果是终止状态,发送完通知后,回到原始状态
    [[NSNotificationCenter defaultCenter]postNotificationName:kPairLocatorStatusUpdated object:@(stage)];
    if (stage==1) {  //透露太多了,要被周老板干掉的
        //透露太多了,要被周老板干掉的
    }
    if (stage==1) {  //透露太多了,要被周老板干掉的
        //透露太多了,要被周老板干掉的
    }
    if (stage==1) {  //透露太多了,要被周老板干掉的
        //透露太多了,要被周老板干掉的
    }
}
</code></pre><p>对,转移状态,和UI可以分开处理,免得以后要界面逻辑,还要去状态转移中找代码.</p>
<p><code>变量和类名都起得很不要脸啊,小伙子</code></p>
<h3 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h3><p>这一篇,看起来像硬广啊.</p>
<h3 id="再总之"><a href="#再总之" class="headerlink" title="再总之"></a>再总之</h3><p>Android端也可以很轻松的做移植.</p>
<p>所以做Android的这个操作,差不多就是在做翻译工作,把Objective-C 翻译为 Java就好了.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/programming/20161221-use-status-base-to-handle-complex-operation.html" data-id="ckl153wcm006tzxij69q8fimf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/" rel="tag">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-filter-bluetooth-in-android" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/programming/20161214-filter-bluetooth-in-android.html" class="article-date">
  <time datetime="2016-12-14T02:40:57.000Z" itemprop="datePublished">2016-12-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/programming/20161214-filter-bluetooth-in-android.html">Android上的蓝牙</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>如果说Android和iOS一样,一出新版本,每个用户都回去升级,那我就不用写这篇咯</p>
<h4 id="先说说iOS端的蓝牙扫描"><a href="#先说说iOS端的蓝牙扫描" class="headerlink" title="先说说iOS端的蓝牙扫描"></a>先说说iOS端的蓝牙扫描</h4><pre><code>@param serviceUUIDs A list of &lt;code&gt;CBUUID&lt;/code&gt; objects representing the service(s) to scan for.
//serviceUUIDs是一个过滤NSArray
//根据蓝牙外设的广播信号中的Service UUID来过滤
- (void)scanForPeripheralsWithServices:(nullable NSArray&lt;CBUUID *&gt; *)serviceUUIDs options:(nullable NSDictionary&lt;NSString *, id&gt; *)options;
</code></pre><p>假定说,我们的app需要过滤两个产品的蓝牙信号.那么只要在serviceUUIDs里面填写他们<code>特有</code>Service UUID.</p>
<p>然后,在代理方法中做区分.</p>
<pre><code>- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI{
    // 从广播信号中获取Service UUID 的列表
    NSArray *serviceUUIDs=advertisementData[CBAdvertisementDataServiceUUIDsKey];
    //做一下判断
    if ([serviceUUIDs containsObject:[CBUUID UUIDWithString:@&quot;FFFF&quot;]]){
        //欧耶,这是我们的产品1
    }else if ([serviceUUIDs containsObject:[CBUUID UUIDWithString:@&quot;FFFF&quot;]]){
        //欧耶,这是产品2
        //直接else当然也可以.但是要保险一些嘛
    }
}
</code></pre><p>方便,真是方便</p>
<h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>Android中,貌似没有那么轻松</p>
<p>当然,这就要提起<code>Context</code>里面说的事情了.</p>
<p>BLE是android 4.3引入的,所以最早拥有蓝牙更能的版本,就是API 18.</p>
<p>大概是由于API 18中,蓝牙搜索的方法,有点儿蛋疼,所以,他们改了新的方法吧?</p>
<h3 id="API-21"><a href="#API-21" class="headerlink" title="API 21"></a>API 21</h3><p>先看看API 21怎么搜索蓝牙的.</p>
<p>BluetoothAdapter的一个静态方法</p>
<pre><code>void startScan (List&lt;ScanFilter&gt; filters,ScanSettings settings,ScanCallback callback)
</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>filters</td>
<td>List</td>
<td>ScanFilters for finding exact BLE devices.</td>
</tr>
<tr>
<td>settings</td>
<td>ScanSettings</td>
<td>Settings for the scan.</td>
</tr>
<tr>
<td>callback</td>
<td>ScanCallback</td>
<td>Callback used to deliver scan results.</td>
</tr>
</tbody>
</table>
<p>其中ScanFilter很牛逼</p>
<pre><code>Service UUIDs which identify the bluetooth gatt services running on the device.
Name of remote Bluetooth LE device.
Mac address of the remote device.
Service data which is the data associated with a service.
Manufacturer specific data which is the data associated with a particular manufacturer.
</code></pre><p>这过滤方法,可比iOS的搜索强多了</p>
<p>然而,这个是API 21才有的……</p>
<h3 id="API-18"><a href="#API-18" class="headerlink" title="API 18"></a>API 18</h3><p>由于,咱们要覆盖所有的,拥有BLE功能的手机用户</p>
<p>所以,只能用API 18了.</p>
<pre><code>boolean startLeScan (UUID[] serviceUuids, BluetoothAdapter.LeScanCallback callback);
</code></pre><p>这过滤,和iOS一样了,只能用serviceUUID来过滤.</p>
<p>不过,通过我的实际测试,我发现<code>serviceUuids</code>填写的不能是不同设备的service uuid.</p>
<p>这样做,总是会显示没有<code>match uuid list</code> (有机会再好好研究一下)</p>
<p>那过滤两种设备,可以选择,做两遍这个方法,给不同的callback,好像还省去了用<code>if</code>去判断设备这个工作.</p>
<h4 id="但是-如果有一大排设备需要去过滤呢……"><a href="#但是-如果有一大排设备需要去过滤呢……" class="headerlink" title="但是,如果有一大排设备需要去过滤呢……"></a>但是,如果有一大排设备需要去过滤呢……</h4><pre><code>boolean startLeScan (BluetoothAdapter.LeScanCallback callback);
</code></pre><p>直接全部搜索吧……还过滤啥呀</p>
<p>手动解析广播数据,进行分类,做不同的操作</p>
<pre><code>BluetoothAdapter.LeScanCallback bluetoothScanCallback = new BluetoothAdapter.LeScanCallback() {

    @Override
    public void onLeScan(BluetoothDevice bluetoothDevice, int i, byte[] bytes) {
        //已经搜索过的设备,就不用重新解析啦
        if (locatorList.containsKey(bluetoothDevice.getAddress())){
            LocatorPeripheral peripheral=locatorList.get(bluetoothDevice.getAddress());
            peripheral.updateInformation(i);
        }else if(keyList.containsKey(bluetoothDevice.getAddress())){
            KeyPeripheral peripheral=keyList.get(bluetoothDevice.getAddress());
            peripheral.updateInformation(i);
        }else if(ignoreList.contains(bluetoothDevice)){
            return;
        } else {
            //这里开始重新解析
            VKPeripheral peripheral = VKPeripheral.createPeripheral(i,bytes,bluetoothDevice);
            if (peripheral instanceof LocatorPeripheral){
                //这是设备1
                locatorList.put(bluetoothDevice.getAddress(),(LocatorPeripheral) peripheral);
            }else if (peripheral instanceof KeyPeripheral){
                //这是设备2
                keyList.put(bluetoothDevice.getAddress(),(KeyPeripheral) peripheral);
            }else {
                //这不是咱们的东西
                ignoreList.add(bluetoothDevice);
                return;
            }
            //通知UI

        }
    }
};
</code></pre><p>我水平有限,所以就是这样写的~</p>
<p>这里有个VKPeripheral <code>类名也是直接从iOS版移植过来了</code></p>
<p>用来根据广播信息来新建我自己的蓝牙设备实例.</p>
<p>他生成的KeyPeripheral和LocatorPeripheral都是他的子类.如果不是我们需要的设备,就加到忽略的列表中去.</p>
<h3 id="还有几个小坑"><a href="#还有几个小坑" class="headerlink" title="还有几个小坑"></a>还有几个小坑</h3><p>1.从android 6.0开始,蓝牙扫描如果需要得到结果,就必须获得定位权限(你逗我的吧…凭什么呀)</p>
<p>所以要把这个加到Manifest里面去</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;
</code></pre><p>2.还是android 6.0的锅. 由于6.0可以动态获取权限,所以上面这个权限,直接写在Manifest里面,说不定还没用呢…<br>还要手动的去获取权限</p>
<p>找个Activity加上这一段(不唯一)</p>
<pre><code>if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION)!= PackageManager.PERMISSION_GRANTED) {
    ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION,Manifest.permission.ACCESS_COARSE_LOCATION},1);
}else if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.BLUETOOTH)!=PackageManager.PERMISSION_GRANTED){
    ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.BLUETOOTH,Manifest.permission.BLUETOOTH_ADMIN},1);
}else {
    //你是不是不想用这个App!!
}
</code></pre><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>哎,灵活的Android呀.开放的Android呀.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/programming/20161214-filter-bluetooth-in-android.html" data-id="ckl153wb5003kzxijkkdsv6vq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ble/" rel="tag">蓝牙</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-picture-secret-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hack/20161002-picture-secret-1.html" class="article-date">
  <time datetime="2016-10-02T00:35:10.000Z" itemprop="datePublished">2016-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hack/">黑科技</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hack/20161002-picture-secret-1.html">图片的小秘密</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>搞了一下凝聚最新的招新题目,说起来我也算是凝聚的大粉丝了,5年了,每年都做.</p>
<p>每年都有图片的隐写术.</p>
<h4 id="都是套路"><a href="#都是套路" class="headerlink" title="都是套路"></a>都是套路</h4><p>我也从最早的只知道改个图片后缀名,用zip/unrar把它解压掉,到了后来的用了各种各样的新奇工具,对图片进行处理.</p>
<p>去年和之前的套路感觉差不多,好像是</p>
<pre><code>--图片
|
|
--压缩包
    |
    |
    --图片--答案
</code></pre><p>只不过最后那个图片我没看懂它什么意思罢了~(那时候在考研…)</p>
<h4 id="扑通掉坑里"><a href="#扑通掉坑里" class="headerlink" title="扑通掉坑里"></a>扑通掉坑里</h4><p>今年的,竟然不套路了!</p>
<p>如果你也想搞搞看的话,先<a href="http://vvk.ixuanlun.com/ningju_original.jpg" target="_blank" rel="noopener">下载图片</a>下来,不要看后面的文章</p>
<p>先安利一个工具foremost,以前用的binwalk只能算出偏移量,然后用了ultraEditor手动的分离文件…这个好累(虽然直接用dd命令也可以做,但是那时候我还太嫩~)</p>
<p>foremost不仅可以得到一个文件里面各个其他文件的偏移量,还可以将他们直接分离成单独的文件</p>
<p><img src="http://vvk.ixuanlun.com/foremost.png" alt="foremost"></p>
<p>可以看到,这次的图片里面依然有个rar!</p>
<p>兴高采烈的解压缩了它,看到一个flag.txt,又兴高采烈的打开了它.里面写着:</p>
<pre><code>is this the flag??
</code></pre><p>感觉被骗了.不不不,感觉被套路了.</p>
<p>一脸懵逼,没有思路的时候,突然发现这个图片的缩略图是一个穿着黑丝的MM的腿,而打开之后显示的却是:</p>
<p><img src="http://vvk.ixuanlun.com/ningju_opened.png" alt="displayed"></p>
<p><code>Mac OS X的Preview就是好~Linux和Windows都没有,喔哈哈哈哈哈哈</code></p>
<p>难道说…</p>
<h4 id="缩略图"><a href="#缩略图" class="headerlink" title="缩略图!"></a>缩略图!</h4><p>马上去网上查了一下,图片和缩略图的关系~</p>
<p>原来缩略图不是系统根据原始图片生成的,而是在图片的EXIF中存着缩略图信息.</p>
<p>然后又跑过去查EXIF,在EXIF中发现了一些<a href="http://baike.baidu.com/link?url=7Z322pTpUtXUCPew7bJKEszeywi74GIoBlJxr1xIJV4IAPZ4xGIU-jCJoXyxSyh1Ji1Yd9k_gWzsAlMqN6fCza#5" target="_blank" rel="noopener">小秘密</a>.</p>
<table>
<thead>
<tr>
<th>标签号</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x010E</td>
<td>图像描述</td>
</tr>
<tr>
<td>0x0112</td>
<td>方向</td>
</tr>
<tr>
<td>0xA002</td>
<td>EXIF宽度信息</td>
</tr>
<tr>
<td>0xA003</td>
<td>EXIF高度信息</td>
</tr>
<tr>
<td>0x011A</td>
<td>水平分辨率</td>
</tr>
<tr>
<td>0x011B</td>
<td>垂直分辨率</td>
</tr>
</tbody>
</table>
<p>EXIF高度和垂直分辨率,到底应该改那个呢?试一下就是知道了!</p>
<p>再次使用ultraEditor打开图片,检索A0 03,找到了原始写着的高度为512的hex:02 00.改成了1280的hex:05 00.保存!</p>
<p>结果发现,只是缩略图变大了,原始图片没变大~</p>
<p>不过在缩略图里面发现了一些红色的小点点,估计是flag!</p>
<p>再次用ultraEditor打开图片,检索01 1B,依然是02 00,把他修改成了05 00.保存!</p>
<p>成功了,果然是个<a href="http://vvk.ixuanlun.com/ningju_answer.jpg" target="_blank" rel="noopener">黑丝福利</a></p>
<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>隐写术实在是有意思~当然今年这个题目也不是无缘无故的出来的,据说是在微博上面,9个图片写着1,2,3…9.点击看大图的时候,却是帅哥.</p>
<p>做技术真是有趣~.~</p>
<p>在 CSI:Cyber 里面也有很多差不多的东西,分析员们也会查看图片的meta data(元数据),在里面发现了很多秘密.</p>
<p>最早网络大侠们把种子藏在图片里面,现在把图片藏在缩略图后面,真是越来越有意思了.看看明年的题目是什么吧~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/hack/20161002-picture-secret-1.html" data-id="ckl153wbs0051zxij2ifehdfw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hack/" rel="tag">黑</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-wechat-verify" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/programming/20160925-wechat-verify.html" class="article-date">
  <time datetime="2016-09-24T22:42:31.000Z" itemprop="datePublished">2016-09-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/programming/20160925-wechat-verify.html">微信小网页的安全性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="微信网页的安全性"><a href="#微信网页的安全性" class="headerlink" title="微信网页的安全性"></a>微信网页的安全性</h2><p>这篇文章其实很早以前就可以写一下了,但是当时担心自己的方案不够安全,所以,没有敢写.</p>
<p>为啥子要做防御呢?</p>
<p>因为,我们这次的产品涉及到了比较隐私的信息,严重点儿说,还会涉及到用户的安全.</p>
<p>所以,至少在前端,不能让第三方可以轻松的获取到用户的信息.</p>
<p>由于这次做的网页,不是单网页程序,所以,每个页面所需要的初始数据,都是在URL中体现的,所以第一步需要对URL进行防御</p>
<p>当然,我们也不希望用户在微信外浏览网页.因为这样他们可以看到请求的参数,而且也不利于我们控制入口~</p>
<h4 id="直接开始吧"><a href="#直接开始吧" class="headerlink" title="直接开始吧"></a>直接开始吧</h4><p>一个网页需要获取到点击用户的openid,需要通过微信用户访问<a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=公众号ID&amp;redirect_uri=回调URL" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=公众号ID&amp;redirect_uri=回调URL</a></p>
<p>用户点击了授权,或者以前早就授权过了,才会访问跳转的URL,并且带着openid的参数</p>
<p><code>这一块好像没什么可以攻击的,所以我也没做什么处理</code></p>
<p>服务器收到了redirectURL的请求的时候,是可以获取到openid的.假设,直接根据openid来返回数据,那么微信所在的手机如果网络数据被抓包.就可以很轻松的知道了如何使用接口<code>不使用HTTPS</code></p>
<p>那么伪造openid来获取他人的数据,也变得简单了~所以,我给他加了密,用了很多很多位的对称加密算法,把openid做了加密.每次请求都需要openid和eid(我称为加密的id…)<br>,配对正确,才可以正常的请求,否则就送一个403的大礼包.</p>
<p><code>这上面算是最后一道防线吧?</code></p>
<p>以前参与精益防伪项目的时候,学了好多的保密措施,感觉还是蛮有用的~</p>
<p>当然,这一套还存是在问题的.比如说现在的密钥是固定的,如果根据服务器的Mac来生成,或者再建立一个动态的密钥.就可以防止一个服务器被攻破之后,<br>另外的服务器也被轻松攻破的尴尬现象了.</p>
<p><code>当然咯</code></p>
<p>我们不希望用户在微信外防伪网页,最好的方法就是,阻止用户点击右上角的按钮,选择里面的复制链接,分享给朋友,用浏览器打开……</p>
<p>还好Wechat JS SDK里面就做了这个功能,可以控制微信浏览器,隐藏那些按钮~</p>
<p>各位大大如果找到了漏洞,一定要告诉我呀!这个关系到用户的人身安全的!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/programming/20160925-wechat-verify.html" data-id="ckl153wcs0079zxijfz0exy0c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/" rel="tag">Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-first-experience" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/programming/20160923-android-first-experience.html" class="article-date">
  <time datetime="2016-09-23T00:13:41.000Z" itemprop="datePublished">2016-09-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/programming/20160923-android-first-experience.html">安卓初体验?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="安卓初体验"><a href="#安卓初体验" class="headerlink" title="安卓初体验~"></a>安卓初体验~</h2><p>其实这并不算是初体验吧,毕竟大三的时候已经玩过android开发了,而且看起来也蛮像回事儿的.</p>
<p>只不过当时搞了NFC,业务逻辑和网络请求.剩下的最重要的界面和界面跳转,都是在鹅厂的望神帮我写的~</p>
<h3 id="第一节课其实我没去"><a href="#第一节课其实我没去" class="headerlink" title="第一节课其实我没去"></a>第一节课其实我没去</h3><p>那一节课,据说老师讲了布局文件</p>
<p>然后好像就布置了一个计算器的作业,然后就没什么了.</p>
<p>反正,我就在界面编辑器里面拖控件.然后findViewById,之后给他们做了一些逻辑~</p>
<h3 id="第二节课说是要做SD卡读取图片-并且显示出来"><a href="#第二节课说是要做SD卡读取图片-并且显示出来" class="headerlink" title="第二节课说是要做SD卡读取图片,并且显示出来"></a>第二节课说是要做SD卡读取图片,并且显示出来</h3><p>我一想,觉得有点儿难啊,于是就开始查官方文档去了,</p>
<p>整理了一下,获取文件夹的路径,文件夹内文件这些好像都不难.</p>
<p>选择一个内容显示估计也不难,但是如何做一个漂亮的选择页面,可能比较复杂.</p>
<p>我打算用GridView,做一个和相册一样.</p>
<h3 id="Let’s-do-this"><a href="#Let’s-do-this" class="headerlink" title="Let’s do this"></a>Let’s do this</h3><p>先搞了一个SDCardHelper的类(写iOS时候留下的习惯,各种Helper)</p>
<pre><code>//外部储存是否可写
static public boolean isExternalStorageWritable()
//外部储存是否可读
static public boolean isExternalStorageReadable()
//储存路径
static public String storagePath()
//为GridView用的文件列表
static public List&lt;GridItem&gt; getFileList()
</code></pre><h4 id="Android的GridView和iOS的UICollectionView好像差不太多"><a href="#Android的GridView和iOS的UICollectionView好像差不太多" class="headerlink" title="Android的GridView和iOS的UICollectionView好像差不太多"></a>Android的GridView和iOS的UICollectionView好像差不太多</h4><p>Android的GridView需要的适配器里面需要重写</p>
<pre><code>public int getCount();
public Object getItem(int position);
public long getItemId(int position);
public View getView(int position, View convertView, ViewGroup parent);
</code></pre><p>iOS的UICollectionView需要实现DataSource协议的</p>
<pre><code>-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView;
-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section;
-(UICollectionViewCell*)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
</code></pre><p>这样就可以正常显示一个GridView(UICollectionView)</p>
<p>可是,我要自定义控件呀!不然用原始的GridView中每个item的View或者UICollectionView中原始的UICollectionViewCell<br>,那得多难看…</p>
<p>在iOS中,只要写一个继承于UICollectionViewCell的类,对它进行界面操作,数据操作,并且在Protocol中复用Cell并且返回,就可以完成目的</p>
<p>在Android中,貌似没有类似UICollectionViewCell的东西.所以得自己重写一个类,用来持有Item的xml布局文件中的各个控件</p>
<pre><code>import android.widget.ImageView;
import android.widget.TextView;

/**
 * Created by vikingwarlock on 16-9-23.
 * This is the class for view
 */
public class GridItemView {
    public ImageView imageView;
    public TextView filename;
}
</code></pre><p>之前的图片列表,也专门写了一个类,用来存放这个数据</p>
<pre><code>import java.io.Serializable;

/**
 * Created by vikingwarlock on 16-9-23.
 * This is a class that represent a grid item
 */
public class GridItem implements Serializable{
    public String filepath;
    public String filename;
}
</code></pre><p>这里用了一个<code>Serializable</code>,是为了后面Intent传递用的~</p>
<p>最后在Adapter类里面实现View</p>
<pre><code>@Override
public View getView(int position, View convertView, ViewGroup parent) {
    GridItemView item;
    GridItem data = gridItemList.get(position);
    if (convertView == null) {
        convertView = inflater.inflate(R.layout.gridviewitem, null);
        item = new GridItemView();
        item.filename = (TextView) convertView.findViewById(R.id.itemName);
        item.imageView = (ImageView) convertView.findViewById(R.id.itemImage);
        convertView.setTag(item);
    } else {
        item = (GridItemView) convertView.getTag();
    }
    ImageLoader.getInstance().displayImage(&quot;file://&quot;+data.filepath,item.imageView);
    item.filename.setText(data.filename);
    return convertView;
}
</code></pre><p>界面就差不多搞定了~</p>
<p>至于点击效果,iOS依然是实现一个Protocol~就可以了</p>
<pre><code>-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath;
</code></pre><p>Android需要手动添加</p>
<pre><code>GridView gv = (GridView) findViewById(R.id.gridView);
if (gv != null) {
    gv.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        public void onItemClick(AdapterView&lt;?&gt; parent, View v, int position, long id) {
            GridItem item = datalist.get(position);
            Intent intent=new Intent();
            intent.setClass(SDView.this,MainActivity.class);
            Bundle bundle=new Bundle();
            bundle.putSerializable(&quot;result&quot;,item);
            intent.putExtras(bundle);
            setResult(2,intent);
            finish();
        }
    });
</code></pre><p>这里的gv是GridView的意思,不要想歪了.</p>
<p>做了一堆和Bundle有关的事情,主要是为了Intent中可以传递一个对象,而不仅仅是字符串.</p>
<p>setResult()用来传递一个Intent回上一个需要Result的Activity.</p>
<p>finish()就是结束当前Activity.</p>
<p>这个花了我最多时间的东西就这样做完了~</p>
<p>当然啦,后面还遇到了图片显示的问题.比如卡住啊,比如OOM啊~最后借助了<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">universal-image-loader</a><br>都解决了!!</p>
<p>最后坐在旁边的同学跟我说,他们的代码,只有几十行.原来老师给的demo中获取图片是这样写的</p>
<pre><code>@Override
public void onClick(View v) {
    Intent intent = new Intent();
    intent.setType(&quot;image/*&quot;);
    /* 使用Intent.ACTION_GET_CONTENT这个Action */
    intent.setAction(Intent.ACTION_GET_CONTENT);
    /* 取得相片后返回本画面 */
    startActivityForResult(intent, 1);
}
</code></pre><p>我好生气!说好的操作SD卡呢!</p>
<p>这样的写法,和iOS中的UIImagePickerViewController一样了~</p>
<p>Anyway,至少我学会了自定义控件的GridView,体验了一把OOM,还学习了SDCard的操作</p>
<p>还望各位大大指导我!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/programming/20160923-android-first-experience.html" data-id="ckl153waj0024zxijxmiy2ak6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-we-do-what-we-want-to-do" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/life/20160920-we-do-what-we-want-to-do.html" class="article-date">
  <time datetime="2016-09-20T00:31:14.000Z" itemprop="datePublished">2016-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/life/">日记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/life/20160920-we-do-what-we-want-to-do.html">We do what we want to do</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Solo"><a href="#Solo" class="headerlink" title="Solo"></a>Solo</h1><p>之前鼓励大学生创业.一开始我觉得这是很有趣的事情,觉得大学生终于可以抛开书本,抛开各种习题,去做一些有实际意义的事情了</p>
<p>然而,那一年死了很多创业团队;我觉得一来是因为扛不过大公司,二来是太浮躁.</p>
<p>我承认我在某些方面是很浮躁的一个人,很容易自我膨胀.所以我不适合去管理一个公司.</p>
<h4 id="膨胀-Begin"><a href="#膨胀-Begin" class="headerlink" title="膨胀 Begin"></a>膨胀 Begin</h4><p>不过在做产品方面,我还算是个静得下心得人,所以来整理整理功能模块,调整各部分的交互方式.我还是可以胜任的吧</p>
<h4 id="膨胀-End"><a href="#膨胀-End" class="headerlink" title="膨胀 End"></a>膨胀 End</h4><p>扯远了…这篇日记是来整理一下,开学第3(还是4)周,一边学习一边工作的心得.</p>
<h1 id="This-is-tough"><a href="#This-is-tough" class="headerlink" title="This is tough"></a>This is tough</h1><p>说真的,一边学习一边创业,真的是很难的事情.</p>
<p>我们周Boss,为了公司,牺牲了他的全部.完全没有上课,基本没有休息日,晚睡早起,同时处理很多部分的事情</p>
<p>过去公司在校内,下课去公司,几分钟就好了;现在由于规模扩大,公司搬到了校外的孵化园,虽然环境好了很多,网速也快了许多,周边生活设施也很便利,但是.</p>
<p>离学校太远了,离我的寝室更远!</p>
<p>我偷偷地承认一下,我也会翘一些一些课…</p>
<p>又扯远了…</p>
<p>This is tough, 最难的不是说我们做的东西做不出来.</p>
<p>而最难的是,我们能够高效快速的把我们想做的东西做出来,并且达到预期的效果</p>
<p>为了达到效果,一遍一遍的修改,一遍一遍的推翻重来,一遍一遍的联调修Bug…</p>
<h1 id="I-thought"><a href="#I-thought" class="headerlink" title="I thought"></a>I thought</h1><p>曾今我优化代码,提升App性能,只有一个目的,让用户喜欢iOS,远离Android,因为我是个果粉.所以我喜欢偷偷擅自主张的添加一些小细节,来让用户使用的更加舒服,更加方便.</p>
<h1 id="In-fact"><a href="#In-fact" class="headerlink" title="In fact"></a>In fact</h1><p>现在,我们为了共同的梦想在奋斗.我们想打造一个不一样的自行车世界,也想帮助更多的传统行业进入物联网时代.</p>
<p>为了这个梦想,我们可以牺牲娱乐,可以牺牲一些学业,可以牺牲睡眠.</p>
<p>可以通宵,可以不放假,可以没有薪水,可以一个人干多个人的活儿.</p>
<p>因为,我们愿意这样做</p>
<p>We want to do this.</p>
<h1 id="Sorry"><a href="#Sorry" class="headerlink" title="Sorry"></a>Sorry</h1><p>本来想写一篇鸡汤文,来鼓励爱浪的小朋友们,多学习多实践,多提升自己的能力,踏踏实实的度过大学时光.</p>
<p>结果变成了一篇给自己加油的日记了~</p>
<h4 id="I-hope-I-can-fix-the-bugs-tomorrow"><a href="#I-hope-I-can-fix-the-bugs-tomorrow" class="headerlink" title="I hope I can fix the bugs tomorrow."></a>I hope I can fix the bugs tomorrow.</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/life/20160920-we-do-what-we-want-to-do.html" data-id="ckl153wco006zzxijm6yjxzlo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/soup/" rel="tag">汤</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-all-mitrix" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/study/20160909-all-mitrix.html" class="article-date">
  <time datetime="2016-09-08T23:25:02.000Z" itemprop="datePublished">2016-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/study/20160909-all-mitrix.html">全都是矩阵~</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>研究生的课上了一周了,选课系统有多难过,就不吐槽了.</p>
<p>还好机智的我在选课之前就已经做了充足的准备,保证没有冲突的课,并且确定了抢课顺序.</p>
<p>但是,顺利的抢完课,去听了听课,才有点儿后悔…</p>
<p>信号分析导论: 函数信号集合正交</p>
<p>最优化理论: 正定矩阵,范数……</p>
<p>矩阵理论: 那都是矩阵</p>
<p>嗯,好像难一点的课,都和矩阵有关!!</p>
<p>关键是,矩阵理论我每次都没有位置坐,大家都太积极了!</p>
<p><code>课后自己自学失败</code></p>
<p>我只想对大家说…</p>
<p><code>Don&#39;t make me have to hurt you!!</code></p>
<p>公司新产品研发和研究生那么一堆课,交织在一起…</p>
<p>这是逼着我求肖奈大神附体嘛~</p>
<p>这几周写前端写的我,都有点对iOS手生了…虽然前端真的很爽,但是,</p>
<p>我水平还是太烂了……</p>
<p>等这些产品都上架了,好好地重构一下吧! (好像官网还没写…T_T)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/study/20160909-all-mitrix.html" data-id="ckl153wae001tzxij2wk9uf0p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/diary/" rel="tag">日记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ble-ad-data" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/programming/20160904-ble-ad-data.html" class="article-date">
  <time datetime="2016-09-03T17:36:15.000Z" itemprop="datePublished">2016-09-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/programming/20160904-ble-ad-data.html">BLE的广播帧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前还以为BLE也就GATT那些东西嘛,没什么好说的了</p>
<p><code>其实</code></p>
<p>BLE或者说,蓝牙,的广播帧还是有很多很多奥秘的.还是有些东西可以拿来琢磨琢磨,学习学习</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>至于为什么要突然学习这个东西,肯定是和新产品有关系的,具体的,可以等上市之后,买来一个试试看啊,哈哈哈哈哈哈</p>
<p>另一个原因,这个东西的官方文档真的很难找,至少在 <a href="http://www.bluetooth.com" target="_blank" rel="noopener">www.bluetooth.com</a> 上面我就没有看到讲述广播帧结构的文档,最后在TI的一个文档中,终于找到了相关的内容.</p>
<p>平时用BLE只要是在连接成功之后,搜索Service和Characteristc,后进行读写操作.这样的工作模式,只能一对一,不能做到一对多.但是利用了广播信息,可以做到一对多的发送消息…虽然这时候不能反过来写入.</p>
<h3 id="Let’s-go"><a href="#Let’s-go" class="headerlink" title="Let’s go"></a>Let’s go</h3><p>我们先来上一张图片,看看Bluetooth到底广播了什么吧</p>
<p><img src="http://vvk.ixuanlun.com/bluetoothAD_Data.png" alt="AD"></p>
<p>我是做上位机软件开发的,所以只关心应用层的东西,那么上面图片中,iOS和Android能被处理的数据是标红的那一段</p>
<p>一共31个字节,看起来好像不是很足够,但是由于协议是规定好了的,所以对应的位置表示对应的数据,还是够用的.</p>
<p>说说我们熟悉的一些广播信息吧:(iOS端CoreBluetooth的广播帧字典的Key)</p>
<pre><code>1.LocalName (外设名称)
2.ServiceUUIDs (Service列表)
3.ManufacturerData (制造商数据)
4.IsConnectable (是否可连)
</code></pre><p>下面再给点儿我第一次知道的广播信息类型:</p>
<pre><code>1.ServiceData (某个Service的广播数据)
2.TxPowerLevel (传输信号强度~.~,用来计算损耗用...好像暂时没啥用处,反正我也不会算)
3.OverflowServiceUUIDs (没懂他和ServiceUUIDs的区别~.~)
4.SolicitedServiceUUIDs (貌似和从设备没啥关系~.~)
</code></pre><p>说实话,平时用到的只有ServiceUUIDs,因为我们用这个来过滤出来我们需要的蓝牙外设,也用这个来区分不同的硬件.</p>
<p>LocalName的话iOS和Android都已经自动提取并封装成简单的接口了</p>
<p>上面是软件层面的东西,我们来看看硬件层面的呗~</p>
<p>一个广播帧会有很多类型的数据,每个类型有自己的<code>type</code>,上位机也是通过type字段来分辨数据是UUID还是Name或者其他的东西~</p>
<p>每一类数据都由3部分组成:</p>
<pre><code>1.length of data (这个type的总长度)
2.type (定义type)
3.data (根据type的协议来填入数据)
</code></pre><p>这里简单的列举几个type:</p>
<pre><code>0x02 不完整的16位UUID
0x04 不完整的32位UUID
0x06 不完整的128位UUID
0x08 设备全名
0x16 16位UUID的Service Data
0x20 32位UUID的Service Data
0x21 128位UUID的Service Data
0xFF 制造商自定义的数据
</code></pre><h4 id="Example-of-Peripheral-and-Bluetooth-Central"><a href="#Example-of-Peripheral-and-Bluetooth-Central" class="headerlink" title="Example of Peripheral and Bluetooth Central"></a>Example of Peripheral and Bluetooth Central</h4><p>一台名叫VK的外设,公布了一个Service UUID <code>3344</code>,<code>5566</code>;其中<code>3344</code>的Service Data是”0xAA,0xBB,0xCC”,制造商的自定义数据是”0x12,0x34,0x56,0x78”</p>
<p>那么他的广播数据是~</p>
<pre><code>04 08 56 4B 05 02 44 33 66 55 06 16 44 33 cc bb aa 07 FF 00 00 78 56 34 12
</code></pre><p>拆分数据分析分析</p>
<pre><code>04 08 56 4B
长度4 设备完整名称 V K

05 02 44 33 66 55
长度5 不完整的16位列表 3344 5566

06 16 44 33 cc bb aa
长度6 16位UUID的ServiceData UUID=3344 数据是 AA BB CC

07 FF 00 00 78 56 34 12
长度7 厂商自定义数据 厂商ID=0000 厂商自定义数据=12345678
</code></pre><p><code>如果有错误不要打我…</code></p>
<p>iOS端解析广播数据</p>
<pre><code>-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI
{
    // 名字的字符串
    NSLog(@&quot;Name %@&quot;,advertisementData[CBAdvertisementDataLocalNameKey]);
    // CBUUID的NSArray
    NSLog(@&quot;Service UUID %@&quot;,advertisementData[CBAdvertisementDataServiceUUIDsKey]);
    // Key为CBUUID,Value为NSData的NSDictionary
    NSLog(@&quot;Service Data %@&quot;,advertisementData[CBAdvertisementDataServiceDataKey]);
    // 制造商的数据NSData
    NSLog(@&quot;ManufacturerData %@&quot;,advertisementData[CBAdvertisementDataManufacturerDataKey]);
}
</code></pre><p>Android端解析</p>
<pre><code>@Override
    public void onLeScan(final BluetoothDevice device, int rssi,
            byte[] scanRecord) {
        // scanRecord 就是所有的广播数据呗
   }
</code></pre><p>iOS端为了隐私保护,做了各种各样奇怪的限定,所以不像Android那么爽,可以直接把广播帧的字节流都提取出来,所以就只能好好阅读协议,才能让iOS的App获取到想要的数据</p>
<p>相同的,Android虽然数据很开放,下位机可以不按照BLE协议去设置广播数据,Android App依然可以读得出来数据,但是解析数据就很头疼的样子了.</p>
<p>嗯,各有各的好处~</p>
<h4 id="BTW"><a href="#BTW" class="headerlink" title="BTW"></a>BTW</h4><p>其中一个type是</p>
<pre><code>0x17  Public Target Address
目标Mac地址
</code></pre><p>官方定义是</p>
<p>The Public Target Address data type defines the address of one or more intended recipients of an advertisement when one or more devices were bonded using a public address. This data type is intended to be used to avoid a situation where a bonded device unnecessarily responds to an advertisement intended for another bonded device.</p>
<h4 id="what-are-you-弄啥嘞…"><a href="#what-are-you-弄啥嘞…" class="headerlink" title="what are you 弄啥嘞…"></a>what are you 弄啥嘞…</h4><p>我YY他的用处就是,这个BLE设备只能被<code>指定Mac地址</code>的主机连接.</p>
<p>好啦,这次又学到了一点儿蓝牙的知识,写个文章当笔记.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vkwk.site/programming/20160904-ble-ad-data.html" data-id="ckl153wap002kzxij2r9dtes9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ble/" rel="tag">蓝牙</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&amp;laquo; __(&#39;prev&#39;)</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/">__(&#39;next&#39;) &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/book/">书记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/wtf/">什么鬼</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/study/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hack/">黑科技</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arduino/" rel="tag">Arduino</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ide/" rel="tag">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mini/" rel="tag">Mini</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/working/" rel="tag">Working</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/" rel="tag">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yearly/" rel="tag">年记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unknow/" rel="tag">怎么算呢</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/diary/" rel="tag">日记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/soup/" rel="tag">汤</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/play/" rel="tag">玩玩的</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/note/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ble/" rel="tag">蓝牙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hack/" rel="tag">黑</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 15.71px;">Android</a> <a href="/tags/arduino/" style="font-size: 10px;">Arduino</a> <a href="/tags/ide/" style="font-size: 10px;">IDE</a> <a href="/tags/mini/" style="font-size: 10px;">Mini</a> <a href="/tags/python/" style="font-size: 15.71px;">Python</a> <a href="/tags/web/" style="font-size: 10px;">Web</a> <a href="/tags/working/" style="font-size: 17.14px;">Working</a> <a href="/tags/ios/" style="font-size: 17.14px;">iOS</a> <a href="/tags/yearly/" style="font-size: 18.57px;">年记</a> <a href="/tags/unknow/" style="font-size: 14.29px;">怎么算呢</a> <a href="/tags/diary/" style="font-size: 20px;">日记</a> <a href="/tags/soup/" style="font-size: 10px;">汤</a> <a href="/tags/play/" style="font-size: 11.43px;">玩玩的</a> <a href="/tags/note/" style="font-size: 12.86px;">笔记</a> <a href="/tags/ble/" style="font-size: 14.29px;">蓝牙</a> <a href="/tags/Hack/" style="font-size: 11.43px;">黑</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/01/">一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/01/">一月 2010</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/life/20210211-2021-what-a-tough-year.html">重启2020</a>
          </li>
        
          <li>
            <a href="/life/20200121-2020-enbrace-change.html">2020唯一不变的是变化</a>
          </li>
        
          <li>
            <a href="/uncategorized/20191027-digital-signature-and-verification.html">数字签名于验签</a>
          </li>
        
          <li>
            <a href="/uncategorized/20191027-xml-validation.html">XML格式校验</a>
          </li>
        
          <li>
            <a href="/study/20191004-ansible.html">ansible</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Viking Warlock<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>