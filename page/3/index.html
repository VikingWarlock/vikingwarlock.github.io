<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>VikingWarlock</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="VikingWarlock&#39;s daily life and develop experience">
<meta property="og:type" content="website">
<meta property="og:title" content="VikingWarlock">
<meta property="og:url" content="http://vikingwarlock.gitee.io/hexosource/page/3/index.html">
<meta property="og:site_name" content="VikingWarlock">
<meta property="og:description" content="VikingWarlock&#39;s daily life and develop experience">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Viking Warlock">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="VikingWarlock" type="application/atom+xml">
  
  
    <link rel="icon" href="/avatar.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/hexosource/css/style.css">

  

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/hexosource/" id="logo">VikingWarlock</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/hexosource/">Home</a>
        
          <a class="main-nav-link" href="/hexosource/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://vikingwarlock.gitee.io/hexosource"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-reading-note-release-it-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/book/20180908-reading-note-release-it-2.html" class="article-date">
  <time datetime="2018-09-08T00:14:54.000Z" itemprop="datePublished">2018-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/book/">书记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/book/20180908-reading-note-release-it-2.html">透明度、适应</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>《发布!软件的设计与部署》这本书终于读完了，不过我感觉我现在的水平还有很多内容没有理解。所以这本书，我总还要找机会搞来的！</p>
<h3 id="Chapter"><a href="#Chapter" class="headerlink" title="Chapter"></a>Chapter</h3><p>这剩下的两节都是第四部分:运营 的内容，帮助</p>
<h4 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h4><p><code>透明性是指这样一种特性，它能让操作员、开发者和商业赞助商理解系统的历史趋势、当前状态、瞬间状态和未来设想</code></p>
<p>如果系统的透明性很差，那么即便我们发现系统出现了异常或者故障，也很难快速的找到问题的根源。按照我的猜想，透明性大概就是在系统的各种关键点(继承点)增加控制接口、log记录等。因为在遇到问题的时候，知道的信息越多，定位问题越方便；组件提供的接口越多，操作起来越方便。</p>
<p>想一下，如果好不容易发现了问题，结果这个问题的解决方法只能通过修改系统代码(更新软件)来解决，那实在是太痛苦了；如果一个系统中很多的操作都是根据配置文件来确定的，那只要修改了配置文件，并重启服务(软件)，那么问题就解决了，岂不是爽歪歪。</p>
<p><code>没有透明性的系统不能在生产中长期存在。如果管理员不知道它正在做什么，就不能调整和优化。如果开发者不知道在生产环境中什么能行什么不行，就不能对它进行增强和更新</code></p>
<p>这一章从4个层次解释了透明性：历史趋势、未来预测、当前状态、瞬间行为。</p>
<p><code>历史趋势</code>很有意思，作为一个初等程序员，对于历史问题，我可能只会关心什么时候产生错误警告，错误警告产生的原因，触发条件这些东西。而资深架构师运营经理总是可以问一些小白、普通程序员不会想到的问题。比如：我们昨天有多少订单；第一季度我们使用了多少磁盘空间；过去三年顾客流量的增加和CPU使用率增加相比的结果～</p>
<p>当我们觉得没有看到警告，没有看到错误就心满意足的时候，他们总是可以想的更加长远(现在我也可以想的更长远啦～)</p>
<p><code>当前状态</code>简单说，就是要给出足够的数据来反映系统运行的状态，产生了多少报警，多少异常，内存用了多少，还剩多少，线程数量，可用线程、繁忙线程、等等等等。不能让系统运行的像个薛定谔的猫一样。说到这里，作者也提到了日志的规范性，不能说有了日志就大功告成了，日志要分级，要有良好的格式，让人阅读的方便。不然几万几万的日志，即使知道关键内容在里面，也会让人失去探索的兴趣。</p>
<h4 id="适应"><a href="#适应" class="headerlink" title="适应"></a>适应</h4><p>适应性差不多就是兼容性的意思。系统在不断的被完善，老用户如何适应新系统，新系统如何适应老用户。开发人员如何用更低的成本去维护系统，去更新系统。这就是这一章的主要内容。</p>
<p><code>依赖注入</code>,<code>对象设计</code>,<code>极限编程实践</code>,<code>敏捷数据库</code>，这是适应性软件设计的四个方法。简单的说他们都在鼓励松耦合，高内聚，提高向下兼容的能力。</p>
<p><code>发布应无害</code> 讲到了’部署成本太高<code>，</code>零停机时间部署`和其他的几点。这两点单独拿出来说，是因为，颠覆了我的认知～</p>
<p>本以为部署一个系统多容易啊，改了新的代码，重启服务即可，有什么成本呢？实际上专业的团队在部署的时候，需要创建发布分支，发布说明文档，与营销沟通，计划执行验证部署，后续的技术支持。这些都是人力成本～</p>
<p>平时看到停机维护的情况比较多，所以对<code>零停机时间部署</code>这个概念还是比较好奇的。说的是，部署行版本，可以一步一步慢慢来，按阶段分解部署，不是立刻添加改变删除一些东西。增加各种兼容性。</p>
<h3 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h3><p>上一篇中没有说到 <code>快速失效</code> ，在第18章《适应》中讲到了一个例子，让我猛的想起了这个有用的设计～</p>
<p>比如，一个请求，我们其实早就知道，这个操作可能要出现错误了，却还是让请求做到了出现异常的时候，才反馈。就相当于客户白等了很久得知，自己想做的事情不能被达成。所以快速失效可以相当于做一些中间件吧～提前做一些处理，早就知道要失败了，就直接返回，不再继续执行操作。</p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>这本书终于读完了，我肯定还会再搞来的！现在觉得一些书看不懂，没意思，说不定并不是书的问题，而是自己段位太低了～哈哈</p>
<p>(每次写一篇博客，都会晚睡一次～)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/book/20180908-reading-note-release-it-2.html" data-id="ckl153wby005czxij39n7u793" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/note/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-reading-note-release-it" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/book/20180905-reading-note-release-it.html" class="article-date">
  <time datetime="2018-09-04T21:47:27.000Z" itemprop="datePublished">2018-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/book/">书记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/book/20180905-reading-note-release-it.html">第一篇读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>这是第一篇读书笔记，最近看了几本有点厉害的书。我担心我看了之后又忘记了，所以还是有必要记录一下的。</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>这本书是一个很多年工作经验的架构师大神根据自己的各种亲身经历总结出来的一些东西。总共分为4个部分:稳定性、容量、一般设计问题、运营。</p>
<p>目前呢，我才读到了178页，差不多是第四部分运营的一半位置，所以这本书终于将要被我读完了！</p>
<p>这本书读的时间很长，因为他不是一本工具书，它是一本和小说一样的书，通过各种故事来引出问题和解决方案。有时候一些情况是我现在无法理解的，因为我还没有接触过作者大大所做的那种超高并发，大用户，等复杂场景。也有可能是因为作者大大做的系统都是从最最最底层开始一直垒到最顶层的，而我现在都是使用各种框架，把最难的部分或者最可能出问题的部分交给了其他大佬们去解决了。<br>其实这个并不是最好的习惯，因为在书的P35就提到了一个点<code>厂商API库</code>，这里说有时候我们使用的第三方API被封装的特别漂亮，但是其实他的实现非常丑陋，甚至存在很多的缺陷～但是其实我们这些小角色现在也只能抱怨抱怨，因为并没有能力和时间去修改它～～</p>
<h3 id="Chapters"><a href="#Chapters" class="headerlink" title="Chapters"></a>Chapters</h3><p>讲一下这本书的四个部分都是什么具体内容吧～</p>
<p>目录其实可以在网上查到，所以我也不说了。但是这四个部分讲的内容大概是什么我倒可以稍微概括一下，因为说不定未来遇到了问题，可以很针对性的去找对应的章节。</p>
<p><code>注意，下面被这样标记的部分就是书中原话的意思～</code></p>
<hr>
<h4 id="第一章-稳定性"><a href="#第一章-稳定性" class="headerlink" title="第一章:稳定性"></a>第一章:稳定性</h4><p>这一章介绍了稳定性反模式和稳定性模式，其中稳定性反模式指的是一些设计会导致导致没考虑到的小问题被方法，导致系统快速的崩溃。而使用稳定性模式，就可以降低这种崩溃的风险。</p>
<p>在介绍稳定性的时候讲到了<code>故障链</code>，这其实很好理解，一个很小的故障，导致了另一个未知故障的发生，进而导致另另一个未知故障的发生，进而满满的发现所有的模块都爆了。就像什么火箭飞船飞机什么的，一开始发现一个很小的异常，然后慢慢地慢慢地，全屏都是error然后爆炸了～</p>
<p>这一章讲到了一个凌晨5点崩溃的故事，说的是一个服务器每天凌晨5点都会死掉。我相信这套系统在测试阶段应该没有出现过这种问题，但是在生产服务器中，却出现了这个崩溃问题。作者通过获取故障服务器的线程转储(我并不知道这是什么)，tcpdump抓包，分析得到这个崩溃是由TCP链接的不对称导致的。<br>TCP如果双方都不通知对方，这个链接中断了，那么即使物理线路真的断了，那他们也以为没有断。而在生产服务器中，又一个防火墙角色的存在，导致情况变得更加复杂。</p>
<p>防火墙检查到外部节点超过若干时间没有和本机通信了，便会移除防火墙里面的记录，导致后续外部节点再次通信产生失败。这这个例子中，防火墙保护了数据库服务器，而链接数据库服务器的应用服务器，由于过了一个晚上的休息时间，使得防火墙中对应的记录都被删除了，所以应用服务器再也无法跟数据库服务器进行通信了，于是这些线程全部被阻塞了，最终系统崩溃了。</p>
<p>虽然这个故事讲的并不是生产环境和测试环境的事情，但是我觉得这个故事我对他印象还是很深刻的。</p>
<p>之后说了<code>连锁反应</code>， 假设分布式服务器集群有若干台，他们的故障概率为x，那么当某一台服务器挂了之后，剩下的负载服务器的故障概率就会升高，因为他们分担了之前服务器的负载。以此类推，当更多的服务器挂掉之后，剩下的服务器的故障概率会变得高的可怕，说不定就会导致系统崩溃。</p>
<p><code>用户是可怕的</code>，<code>每个用户都好用了更多的内存</code>，这应该不需要再解释了。</p>
<p><code>无共享</code>,在软件设计的时候我还是挺喜欢使用单例的，因为这是一个全局的东西，可以被各个模块共享使用。但是在系统架构时，为了可扩展性，会希望无共享架构。但是无共享会导致失效备援能力变弱。所以大佬的建议是:<code>减少共享资源</code>。我理解就是除了那些必不可少的资源需要共享，其他的资源可以通过让两个应用服务器彼此做备援服务器的方法来实现援救。</p>
<p><code>去耦合中间件</code>这个不好解释，总是中间件很有用就对了，’通过完全姐耦合来避免大部分失效模式’</p>
<p>这一章写了那么多，因为他竟然有94页！所以看得我心力憔悴。</p>
<hr>
<h4 id="第二章-容量"><a href="#第二章-容量" class="headerlink" title="第二章:容量"></a>第二章:容量</h4><p>这一章看名字就大概明白意思了。各种暴力环境呗。大用户，高并发，大容量储存，之类的…</p>
<p>写几个印象深刻的点：</p>
<p><code>容量的神话</code>: 1.”CPU很便宜”。但是机箱很贵啊！4个CPU用一个机箱，那5个CPU可能就需要2个机箱，此时每个CPU的成本就被抬高了啊。2.”存储很便宜”。但是服务器不止一台，而且需要考虑RAID的影响，操作系统大小，应用程序大小等等。所以购买的容量远远小于可以储存数据的容量。根据乘法效应来算，这储存还是挺贵的。3.”带宽很便宜”。现在一般两种带宽服务，按时间计费，固定带宽不限流量，每月支付固定的金额；按流量支付，每月流量小于一个阈值，就可以支付稍低的固定费用，但是如果流量超出则会付出惨痛的代价。于是讨厌的爬虫脚本，或者服务器中传输垃圾信息(每次1kb，累计起来也是钱啊)都会导致带宽变得很昂贵。</p>
<p><code>JSON的黑暗面</code>这个其实不难理解，因为有的程序员会使用json来执行函数或者命令，这个操作是很有风险的，万一个黑客猜到了，就完蛋了。</p>
<p><code>昂贵的空白图片</code>,<code>多余的HTML表格</code>,<code>刷新按钮</code>,<code>空白</code>-&gt;<code>这些都是HTML中浪费的空间</code>，他们虽然不会影响什么，但是，会浪费很多的流量(都是钱啊！)</p>
<p>‘海外来的RMI’， 这个故事我还没看懂～。～</p>
<hr>
<h4 id="第三章-一般设计问题"><a href="#第三章-一般设计问题" class="headerlink" title="第三章:一般设计问题"></a>第三章:一般设计问题</h4><p><code>虚拟IP地址</code>，使用虚拟IP地址，可以用作失效备援。一堆失效备援服务器一个作为主动运行服务器，另一台作为备援服务器，他们有自己真实的IP，也会有一个虚拟IP。但是虚拟IP只会指向正在运作的主要服务器，当主要服务器故障之后，便通过将备用服务器迁移到这个虚拟IP上来保证服务可用。</p>
<hr>
<h4 id="第四章-运营"><a href="#第四章-运营" class="headerlink" title="第四章:运营"></a>第四章:运营</h4><p>这一章还没看完，不着急。</p>
<hr>
<p><code>注意，上面被这样标记的部分就是书中原话的意思～</code></p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>嗯，这是看了那么多一口气写的笔记，所以花了我2小时的时间，下次读书笔记还是一边读一遍写吧！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/book/20180905-reading-note-release-it.html" data-id="ckl153wc0005fzxijx3fgzipe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/note/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-BLEoE-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/programming/20180826-BLEoE-1.html" class="article-date">
  <time datetime="2018-08-25T17:38:38.000Z" itemprop="datePublished">2018-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/programming/20180826-BLEoE-1.html">BLEoE(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>蓝牙的传输距离实在是不够长，对于我这种调试人员来说，如果可以有一种方法，远程的调试蓝牙外设，那岂不是超级爽歪歪嘛？</p>
<p>所以某一天洗澡的时候，我就打算使用网络来传输蓝牙数据～</p>
<p>借鉴OSI分层或者网络分层的结构，我觉得只要对BLE传输的数据做一层封装，再通过tcp来传输就可以解决这个问题。</p>
<h3 id="Let’s-do-it"><a href="#Let’s-do-it" class="headerlink" title="Let’s do it"></a>Let’s do it</h3><p>所以这个系统需要至少三个东西，一台作为central的硬件，一台作为peripheral的硬件，以及一个将他们连在一起的服务器。</p>
<p>由于我手上恰恰恰恰好有两台Linkit One物联网开发平台，而且它本身就拥有蓝牙，Wi-Fi的功能，所以central和peripheral肯定就用这两个硬件来试验了～</p>
<p>服务器的话，测试阶段也可以很简单，只要简简单单的将两方的数据做一个交换就好了。再这个阶段并不需要安全认证，多用户绑定，数据正确性检查，数据缓存等等功能，<br>只要交换就好！</p>
<p>因为python写的贼熟悉了，所以当然还是搞一个简单的python socket服务器比较好。</p>
<p>这个项目开个源吧</p>
<p>Coding.Net : <a href="https://git.coding.net/vikingwarlock/BLEoE.git" target="_blank" rel="noopener">https://git.coding.net/vikingwarlock/BLEoE.git</a></p>
<p>Github: <a href="https://github.com/VikingWarlock/BLEoE.git" target="_blank" rel="noopener">https://github.com/VikingWarlock/BLEoE.git</a></p>
<p>两个进度会不一样，因为github上面还是不要留太多的草稿吧</p>
<h4 id="TCP-or-UDP"><a href="#TCP-or-UDP" class="headerlink" title="TCP or UDP"></a>TCP or UDP</h4><p>嗯，这个问题可能会比较有争议。一开始我是打算使用udp的，因为会比较快，我担心未来网络延迟或者服务器性能不佳会导致数据包在网络上耽误较长的时间，导致蓝牙操作超时。<br>可是udp很不可靠，万一出事情了，反而得不偿失。所以先使用tcp来测试测试。</p>
<p>先贴一下我简简单单搞得2用户数据交换的tcp服务器代码吧</p>
<pre><code>import asyncore
import socket

handler_list = {}


class EchoHandler(asyncore.dispatcher_with_send):

    def configure_local_address(self, address):
        self.address = address

    def configure_target_address(self, address):
        self.target_address = address

    def handle_read(self):
        data = self.recv(8192)
        if data and self.target_address:
            hd = handler_list.get(self.target_address)
            if hd:
                hd.send(data)
            else:
                self.target_address = None
                self.send(&quot;fail to send, target is down&quot;)
        else:
            self.send(&quot;no target&quot;)

    def handle_close(self):
        handler_list[self.address] = None
        self.close()
        print &apos;connection from %s lost&apos; % repr(self.addr)


class EchoServer(asyncore.dispatcher):

    def __init__(self, host, port):
        asyncore.dispatcher.__init__(self)
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind((host, port))
        self.listen(5)

    def handle_accept(self):
        pair = self.accept()
        if pair is not None:
            sock, addr = pair
            print &apos;Incoming connection from %s&apos; % repr(addr)
            handler = EchoHandler(sock)
            handler.configure_local_address(addr)
            handler_list[addr] = handler
            if len(handler_list) &gt; 1:
                it1 = handler_list.values()[0]
                it2 = handler_list.values()[1]
                it1.configure_target_address(it2.address)
                it2.configure_target_address(it1.address)

    def handle_close(self):
        self.close()


server = EchoServer(&apos;0.0.0.0&apos;, 3344)
asyncore.loop()
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/programming/20180826-BLEoE-1.html" data-id="ckl153wa40017zxij2sb3bop7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/play/" rel="tag">玩玩的</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-curve-fitting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/programming/20180810-curve-fitting.html" class="article-date">
  <time datetime="2018-08-10T00:08:29.000Z" itemprop="datePublished">2018-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/programming/20180810-curve-fitting.html">曲线拟合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>有个叫做应变片的东西，每个应变片的物理特性都不同，所以收到相同的力时，不同的应变片得到的信号可能不太一样。</p>
<p>所以，每个应变片都需要做一些配置。</p>
<p>所以，我们需要一个程序来收集数据。</p>
<p>比如我们用一组标准力来测量信号，就可以获得到一组数据对:(N1,Sig1),(N2,Sig2)…</p>
<p>已知: 这是N和Sig是线性关系,所以这个要拟合的不是曲线，是条直线～</p>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>是时候，上主题了。</p>
<p>凭我模模糊糊的记忆，我感觉好像是，最优化的内容。好像是，牛顿法？</p>
<p>所以我就去查了牛顿逼近法，查了半个下午，才发现这个是求方程根的～</p>
<p>后来模模糊糊的想起来，好像是线性规划，只要求Yi和F(Xi)的差的和的最小值，应该就是最接近的解了～</p>
<p>正在这个时候，我突然查查看Apple有没有做什么牛逼的函数给我～</p>
<h3 id="Accelerate"><a href="#Accelerate" class="headerlink" title="Accelerate"></a>Accelerate</h3><p>果然Apple是有这么一个库的，叫做<a href="https://developer.apple.com/documentation/accelerate?language=objc" target="_blank" rel="noopener">Accelerate</a>，专门用来算各种各样的高等数学。</p>
<p>一开始看到了一个<a href="https://developer.apple.com/documentation/accelerate/sparse_solvers?language=objc" target="_blank" rel="noopener">Sparse Solvers</a>是个解方程的东西，于是就列了KX=B的一个矩阵式，使用accelerate提供的解方程函数来计算结果，结果是错的～</p>
<p>因为，直接解方程如果可以解出来，那不就是一个固定的k和b了嘛？然而我是要估计一个k和b，所以肯定不是直接解方程的。</p>
<h3 id="Least-squares"><a href="#Least-squares" class="headerlink" title="Least squares"></a>Least squares</h3><p>最小二乘法，终于让我想起来了这个东西，毕竟是大一时候微积分学的，思考太久很正常。</p>
<p>设Zi=(Yi-F(Xi))^2,将所有的Zi加在一起，这个值如果是最小的，那就意味着估计的曲线和误差是最小的。要使得这个值是最小的，那就可以求所有未知参数的偏导，并使得每个偏导的方程都等于0。</p>
<p>再经过数学推导得到了y=ax+b通过最小二乘法得到a和b的估计值的表达式。</p>
<p>由于我懒得用数学公式编辑器，也懒得截图，所以表达式用纯文字表达。</p>
<pre><code>n:样本个数
X:Xi的和
Y:Yi的和
XX:Xi平方的和
XY:XiYi的和

a=(n*XY-X*Y)/(n*XX-X*X)
b=(Y-X*a)/n
</code></pre><p>这里还是用了accelerate的函数，做了矩阵的乘法来计算XiYi的和</p>
<pre><code>void vDSP_mmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N, vDSP_Length __P);
</code></pre><p>虽然这里可以用另一个函数，就是向量的乘法，但是我一开始写的时候，没找到这个函数(文档都是英文的，还是英文版的高数，看着费力啊～)就是下面这个函数:</p>
<pre><code>void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N);
</code></pre><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>啰嗦了半天贴个代码吧。</p>
<pre><code>void calculateEquation(double*x,double*y,double* key){
    double xy[1];
    double sum_x=0,sum_y=0,sum_xx=0; //这里就对应了上面说的 X,Y,XX,XY
    int n=7;
    vDSP_mmulD(x, 1, y, 1, xy, 1, 1, 1, n);
    for (int i=0; i&lt;n; i++) {
        sum_x+=x[i];
        sum_xx+=x[i]*x[i];
        sum_y+=y[i];
    }
    key[0]=(n*xy[0]-sum_x*sum_y)/(n*sum_xx-sum_x*sum_x);  //k
    key[1]=(sum_y-key[0]*sum_x)/n;  //b
    NSLog(@&quot;y=%lfx+%lf&quot;,key[0],key[1]);
}
</code></pre><p>写的不一定好，但是应该是对的～</p>
<h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><p>作为一个严谨的人，我还是要做点测试的。在网上找了两组数据做了单元测试，因为浮点型，所以可能最后几位数字不一样，就会导致单元测试判断错误。所以得，做点儿近似值～</p>
<pre><code>- (void)testExample {
    double xS[]={0,1,2,3,4,5,6};
    double yS[]={1,2,3,4,5,6,7};
    double k[2];
    calculateEquation(xS,yS,k);
    XCTAssertEqual(k[0], 1.0);
    XCTAssertEqual(k[1], 1.0);
}

-(void)testExample2{
    double xS[]={34.1, 34.137, 34.174, 34.211, 34.248, 34.285, 34.322};
    double yS[]={74.4, 74.40321739130435, 74.4064347826087, 74.40965217391305, 74.41286956521739, 74.41608695652174, 74.41930434782608};
    double k[2];
    calculateEquation(xS,yS,k);
    XCTAssertEqual(round(k[0]*100000), round(0.08695652173913038*100000));
    XCTAssertEqual(round(k[1]*100000), round(71.43478260869566*100000));
}

-(void)testExample3{
    double xS[]={-1.5, -1.38, -1.26, -1.14, -1.02, -0.9, -0.78};
    double yS[]={57.30000000000001, 57.34640000000001, 57.39280000000001, 57.43920000000001, 57.48560000000001, 57.53200000000001, 57.57840000000001};
    double k[2];
    calculateEquation(xS,yS,k);
    XCTAssertEqual(round(k[0]*100000), round(0.38666666666666627*100000));
    XCTAssertEqual(round(k[1]*100000), round(57.88000000000001*100000));
}
</code></pre><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>数学，还是很有用的！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/programming/20180810-curve-fitting.html" data-id="ckl153waz0035zxijj450euyt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/unknow/" rel="tag">怎么算呢</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-wechat-mini-program-bluetooth-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/programming/20180807-wechat-mini-program-bluetooth-1.html" class="article-date">
  <time datetime="2018-08-07T00:15:39.000Z" itemprop="datePublished">2018-08-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/programming/20180807-wechat-mini-program-bluetooth-1.html">微信小程序蓝牙坑(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一时兴起，就想做一个微信小程序了。</p>
<p>花了点时间，决定还是做一个和蓝牙相关的。</p>
<p>看了微信小程序的蓝牙文档，发现还是好理解的。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>1 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/bluetooth.html#wxopenbluetoothadapterobject" target="_blank" rel="noopener">开启蓝牙适配器</a></p>
<pre><code>wx.openBluetoothAdapter(OBJECT)
</code></pre><p>这个说法和Android是一样的，在Android中也是叫蓝牙适配器的，iOS中是CBCentralManager。</p>
<p>2 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/bluetooth.html#wxstartbluetoothdevicesdiscoveryobject" target="_blank" rel="noopener">搜索蓝牙外设</a></p>
<pre><code>wx.startBluetoothDevicesDiscovery(OBJECT)
</code></pre><p>从OBJECT的参数可以知道，程序员们还是挺辛苦的～</p>
<p>为了在Android和iOS上面有统一的接口，自己特地封装了一层。</p>
<p>比如<code>allowDuplicatesKey</code>就是iOS特有的</p>
<p><code>interval</code>是Android后期有的</p>
<p>3 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/bluetooth.html#wxcreatebleconnectionobject" target="_blank" rel="noopener">连接蓝牙外设</a></p>
<pre><code>wx.createBLEConnection(OBJECT)
</code></pre><p>不容易啊，这应该是以iOS为原型设计的接口～</p>
<p>iOS中是让CentralManager来连接外设的，Android中是BluetoothDevice自己提供了连接的方法～</p>
<p>4 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/bluetooth.html#wxonbleconnectionstatechangecallback" target="_blank" rel="noopener">发现服务</a></p>
<pre><code>wx.getBLEDeviceServices(OBJECT)
</code></pre><p>5 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/bluetooth.html#wxgetbledevicecharacteristicsobject" target="_blank" rel="noopener">获取特征</a></p>
<pre><code>wx.getBLEDeviceCharacteristics(OBJECT)
</code></pre><p>6 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/bluetooth.html#wxonbleconnectionstatechangecallback" target="_blank" rel="noopener">设置notify</a></p>
<pre><code>wx.notifyBLECharacteristicValueChange(OBJECT)
</code></pre><p>这里文档中只说了两个tip，也不知道快速订阅多个characteristic有没有做特别的优化，至少写原生Android的时候，订阅多个characteristic并不是那么方便～因为之前的文章里面说了，系统会阻塞～</p>
<p>7 读读写写以及notify的回调</p>
<pre><code>wx.readBLECharacteristicValue(OBJECT)

wx.writeBLECharacteristicValue(OBJECT)

wx.onBLECharacteristicValueChange(CALLBACK)
</code></pre><p>看函数名就能理解，这里最难过的就是字节流操作了～</p>
<h3 id="坑儿"><a href="#坑儿" class="headerlink" title="坑儿"></a>坑儿</h3><p>不知道是不是我手机的问题，蓝牙连接需要特别长的时间～</p>
<p>auto connect，是没有的～如果在连接外设那里不加上timeout的话，他会一直在那儿连接，而且如果连不上，就会一直连不上～</p>
<p>不要想当然的以为只要填写对了characteristicID和serviceID就可以直接读写收，还是要搜索到才行的！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/programming/20180807-wechat-mini-program-bluetooth-1.html" data-id="ckl153wcr0076zxij74i9i3vu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/mini/" rel="tag">Mini</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-qinghai-trip" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/life/20180728-qinghai-trip.html" class="article-date">
  <time datetime="2018-07-27T23:48:48.000Z" itemprop="datePublished">2018-07-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/life/">日记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/life/20180728-qinghai-trip.html">青海</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先上图，回去在写文～</p>
<p>为了节省流量，这里放的是很小的缩略图</p>
<p>但是点击小图，可以看原图</p>
<p><a href="http://vvk.ixuanlun.com/xining_IMG_20180724_164134.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180724_164134.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a><br><a href="http://vvk.ixuanlun.com/xining_IMG_20180724_174519.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180724_174519.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a><br><a href="http://vvk.ixuanlun.com/xining_IMG_20180725_111529.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180725_111529.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a><br><a href="http://vvk.ixuanlun.com/xining_IMG_20180725_161005.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180725_161005.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a><br><a href="http://vvk.ixuanlun.com/xining_IMG_20180726_095213.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180726_095213.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a><br><a href="http://vvk.ixuanlun.com/xining_IMG_20180726_110723.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180726_110723.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a><br><a href="http://vvk.ixuanlun.com/xining_IMG_20180726_163136.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180726_163136.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a><br><a href="http://vvk.ixuanlun.com/xining_IMG_20180726_170122.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180726_170122.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a><br><a href="http://vvk.ixuanlun.com/xining_IMG_20180727_091817.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180727_091817.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a><br><a href="http://vvk.ixuanlun.com/xining_IMG_20180727_103110.jpg" target="_blank" rel="noopener"><img src="http://vvk.ixuanlun.com/xining_IMG_20180727_103110.jpg?imageView2/2/w/320/h/480/format/jpg/q/75"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/life/20180728-qinghai-trip.html" data-id="ckl153wbw0059zxija59hp7c4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/diary/" rel="tag">日记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hid-over-usb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/study/20180717-hid-over-usb.html" class="article-date">
  <time datetime="2018-07-17T09:57:08.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/study/">学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/study/20180717-hid-over-usb.html">HID还是USB</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>大三时候做了精益防伪的第一代防伪芯片的Android版测试读写器。如今这个公司发展的有点儿好，所以，<br>他们出了第二代芯片，增加了更多安全措施。</p>
<p>为了对第二代芯片进行生产测试，我们需要做一个全新的测试软件。那么为了与新一代的RFID芯片进行通信，我们需要写一个底层驱动，来使得外接的<code>USB</code> RFID读写器工作。</p>
<p>这个测试上位机是工作在windows上的，对于一个有强迫症的开发者来说，当时不会选择使用有跨平台特性的java来开发。</p>
<p>我们要了上一代芯片的测试程序，是用C++做的通信和界面(MFC)。然而用C++写界面，肯定是很费劲的。所以我们换个思路。充分利用windows上面可以调用各种dll的特点来解决<code>c++写界面要累死</code>这种尴尬的情况。</p>
<p>这就会引出第一个坑(逐渐远离标题)</p>
<h2 id="C-与C-混合编程"><a href="#C-与C-混合编程" class="headerlink" title="C#与C++混合编程"></a>C#与C++混合编程</h2><p>C++有多难写，应该不用再多说了，我就是那种不到万不得己，是绝对不会去碰C++的垃圾~所以得到了上一版测试程序后，我们看到了之前的RFID读写器驱动代码，将它进行生成，得到了一个dll。</p>
<p>在这个基础上，再封装一个wpf可以使用的库，那简直完美。</p>
<p>于是就直接新建一个C#的库项目，导入之前的底层项目，引入lib文件，(再花了很多精力解决了一些环境路径之类的问题)，终于可以成功生成，在新建的wpf项目中添加引用:</p>
<p>错误：不是一个有效的COM组件！？</p>
<p>于是查了这个错误报告，有的说得用CLR库，就是公共语言运行库，想想好像也有道理。于是又如法炮制了一遍，终于可以成功生成了，再次添加引用:</p>
<p>错误：不兼容！？</p>
<p>于是又去查了一些资料，看到C#和C++混合编程，可以使用DllImport来导入C++ Dll中的函数，不过问题来了，这里在使用DllImport的时候，是需要做一些类型转换的。</p>
<p>毕竟.NET里面的一些数据类型，在C++中是没有的，所以从原理上来想，如果不做一些类型转换或者类型的重新定义的话，操作系统会很迷惑的~</p>
<p>所以，我们就放弃了使用原始C++库这个思路，准备撩起袖子自己写了。（逐渐想起标题）</p>
<h2 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h2><p>既然是重新开始，那就要开始疯狂的查询资料了。之前写过windows的串口通信。所以在我的想象中，他们应该是差不多的吧，把USB口子打开，就得到了input和output的流，之后就可以开开兴兴的进行通信了。</p>
<p>不过，并不是这样的~</p>
<p>作为一个懒惰的程序员，我们下一步想到的，就是找开源库。因为这个项目的时间有点紧张，所以怎么搞得快就得怎么做！</p>
<h3 id="LibUsbDotNet"><a href="#LibUsbDotNet" class="headerlink" title="LibUsbDotNet"></a>LibUsbDotNet</h3><p>首先我们找到了<a href="https://github.com/LibUsbDotNet/LibUsbDotNet" target="_blank" rel="noopener">LibUsbDotNet</a>，仔细研究了他的一些接口，写了一套链接，发送的方法。</p>
<p>USB里面有一些末端(EndPoint)描述，这些末端的ID的第一个bit代表着这个末端的通信方向。如果第一个bit为1，则代表input，如果这个bit为0，则代表output。</p>
<pre><code>public bool connectDevice() {

    UsbRegDeviceList registryList= UsbDevice.AllDevices;

    for (int index = 0; index &lt; registryList.Count; index++) {
        UsbRegistry registy = registryList[index];
        if (registy.SymbolicName.Contains(&quot;5750&quot;) &amp;&amp; registy.SymbolicName.Contains(&quot;0483&quot;))
        {
            bool connect_status= registy.Open(out this.device);
            if (connect_status) {

                foreach (UsbConfigInfo info in this.device.Configs){
                    foreach (UsbInterfaceInfo interfaceInfo in info.InterfaceInfoList) {
                        foreach (UsbEndpointInfo endPoint in interfaceInfo.EndpointInfoList) {
                            System.Console.WriteLine(&quot; id:&quot; + endPoint.Descriptor.EndpointID);
                            if ((endPoint.Descriptor.EndpointID &amp; 0x80) == 0x80)
                            {
                                //in
                                this.reader = this.device.OpenEndpointReader((ReadEndpointID)endPoint.Descriptor.EndpointID);
                                continue;
                            }
                            else {
                                //out
                                this.writer = this.device.OpenEndpointWriter((WriteEndpointID)endPoint.Descriptor.EndpointID);
                                continue;
                            }
                        }

            }

        }

        if (this.writer != null &amp;&amp; this.reader != null)
        {
            return true;
        }
        else {
             return false;
        }
        }
        }
    }
    return false;
}
</code></pre><p>缩进问题请谅解，垃圾visual studio</p>
<p>在学习使用lib-usb的时候，我们了解到了pid和vid。就和串口一样有com1，com2等。上位机(操作系统)通过pid和vid来过滤插入的硬件。</p>
<p>但是，我们发现使用lib usb的工作原理貌似不是这样的。感觉他会建立虚拟硬件，虚拟硬件建立完毕后，他的pid和vid都和原来的不一样了，但是好在他的guid里面还是包含了原始的pid和vid，所以采用了上面代码中的方法来过滤来设备。</p>
<p>有了writer和reader之后，对他们进行字节流操作，就ok了。</p>
<p>但是，不行。</p>
<p>还需要设置读入写出的handler，也就是说每一个I/O操作都强制需要有回调函数，否则不会成功调用。</p>
<p>而且当青青成功的使用lib-usb之后，发现做一次写入操作之后，整个软件就卡住了。连问题都没有找到～</p>
<p>Spidey大佬跟我说，usb是仅仅个介质，并不是一种通信。就好比说Wi-Fi是一种介质，真正通信的对象是服务器或者主机</p>
<h2 id="Hid"><a href="#Hid" class="headerlink" title="Hid"></a>Hid</h2><p>HID也叫做人体输入学设备，打开windows的设备管理器，插上鼠标键盘就会显示一个人体输入学设备。</p>
<p>一开始用了一个叫HidLibrary的库，没成功，所以也没有做什么记录。</p>
<p>之后我们恍然大悟！一开始就不应该去学习USB开发，而应该去学习HID的开发！</p>
<p>HID的资料就比较多了~</p>
<p>接下来的内容转自于一位<a href="https://blog.csdn.net/u010875635/article/details/73321066" target="_blank" rel="noopener">前辈大佬</a>，很多的博文也是转载于他的文章。</p>
<p>Windows中对HID的操作比较好理解，和操作系统处理多线程服务器差不多，每个连接都用一个文件来维持。</p>
<p>我对他的代码做了修改，原来版本是异步的发送和接收，这样的做法很高效而且也很健康，只是我们这次的项目似乎用不到这么高级的方法。所以我将它改为了同步发送和同步接收。</p>
<p>这个项目是由HID类和HIDInterface类构成</p>
<p>现在还是直接贴代码吧</p>
<p>HID类:</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.IO;
using Microsoft.Win32.SafeHandles;
using System.Windows;


namespace ReaderCSharp
{
        public class Hid : object
        {
            private IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
            private const int MAX_USB_DEVICES = 64;
            private bool deviceOpened = false;
            private FileStream hidDevice = null;
            private IntPtr hHubDevice;


        /// &lt;summary&gt;
        /// 打开指定信息的设备
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;vID&quot;&gt;设备的vID&lt;/param&gt;
        /// &lt;param name=&quot;pID&quot;&gt;设备的pID&lt;/param&gt;
        /// &lt;param name=&quot;serial&quot;&gt;设备的serial&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public HID_RETURN OpenDevice(UInt16 vID, UInt16 pID, string serial)
            {
                if (deviceOpened == false)
                {
                //获取连接的HID列表
                    List&lt;string&gt; deviceList = new List&lt;string&gt;();
                    GetHidDeviceList(ref deviceList);
                    if (deviceList.Count == 0)
                        return HID_RETURN.NO_DEVICE_CONECTED;
                    for (int i = 0; i &lt; deviceList.Count; i++)
                    {
                    if (!(deviceList[i].Contains(String.Format(&quot;{0:X0000}&quot;, vID)) &amp;&amp; deviceList[i].Contains(String.Format(&quot;{0:X0000}&quot;, pID)))) {
                        continue;
                    }

                        IntPtr device = CreateFile(deviceList[i],
                                                    0xc0000000,//DESIREDACCESS.GENERIC_READ | DESIREDACCESS.GENERIC_WRITE,
                                                    0x00000003,
                                                    0,
                                                    3,//CREATIONDISPOSITION.OPEN_EXISTING,
                                                    0x40000000,//FLAGSANDATTRIBUTES.FILE_FLAG_OVERLAPPED,
                                                    0);
                    if (device != INVALID_HANDLE_VALUE)
                    {
                        HIDD_ATTRIBUTES attributes;
                        IntPtr serialBuff = Marshal.AllocHGlobal(512);
                        HidD_GetAttributes(device, out attributes);
                        HidD_GetSerialNumberString(device, serialBuff, 512);
                        string deviceStr = Marshal.PtrToStringAuto(serialBuff);
                        Marshal.FreeHGlobal(serialBuff);
                        if (attributes.VendorID == vID &amp;&amp; attributes.ProductID == pID &amp;&amp; deviceStr.Contains(serial))
                        {
                            IntPtr preparseData;
                            HIDP_CAPS caps;
                            HidD_GetPreparsedData(device, out preparseData);
                            HidP_GetCaps(preparseData, out caps);
                            HidD_FreePreparsedData(preparseData);
                            //input length ==64
                            hidDevice = new FileStream(new SafeFileHandle(device, false), FileAccess.ReadWrite, 65, true);
                            deviceOpened = true;
                            //BeginAsyncRead();

                            hHubDevice = device;
                            return HID_RETURN.SUCCESS;
                        }
                    }
                    }
                    return HID_RETURN.DEVICE_NOT_FIND;
                }
                else
                    return HID_RETURN.DEVICE_OPENED;
            }

            /// &lt;summary&gt;
            /// 关闭打开的设备
            /// &lt;/summary&gt;
            public void CloseDevice()
            {
                if (deviceOpened == true)
                {
                    deviceOpened = false;
                try
                {
                    hidDevice.Close();
                }
                catch (Exception e) {

                    System.Console.WriteLine(e.Message);
                    System.Console.WriteLine(e.StackTrace);

                }
            }
            }

            /// &lt;summary&gt;
            /// 开始一次异步读
            /// &lt;/summary&gt;
            public void ReadCMD()
            {
            byte[] inputBuff = new byte[65];
            int offset = 0;
            int total_size = 0;
            int read_size = 0;
            try
            {
                while (total_size &lt; 65&amp;&amp;(read_size=hidDevice.Read(inputBuff, offset, 65 - offset)) &gt; 0)
                {
                    total_size += read_size;
                }
                if (total_size &gt;= 65) {
                    OnDataReceived(inputBuff);
                }
            }
            catch {
                EventArgs ex = new EventArgs();
                OnDeviceRemoved(ex);//发出设备移除消息
                CloseDevice();
            }
        }


            public delegate void DelegateDataReceived(object sender, byte[] e);
            //public event EventHandler&lt;ConnectEventArg&gt; StatusConnected;

            public DelegateDataReceived DataReceived;

            /// &lt;summary&gt;
            /// 事件:数据到达,处理此事件以接收输入数据
            /// &lt;/summary&gt;
            protected virtual void OnDataReceived(byte[] e)
            {
                if (DataReceived != null) DataReceived(this, e);
            }

            /// &lt;summary&gt;
            /// 事件:设备断开
            /// &lt;/summary&gt;

            public delegate void DelegateStatusConnected(object sender, EventArgs e);
            public DelegateStatusConnected DeviceRemoved;
            protected virtual void OnDeviceRemoved(EventArgs e)
            {
                if (DeviceRemoved != null) DeviceRemoved(this, e);
            }

            /// &lt;summary&gt;
            ///
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;buffer&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public HID_RETURN Write(byte[] r)
            {
                if (deviceOpened)
                {
                if (!hidDevice.CanWrite) {
                    return HID_RETURN.WRITE_FAILD;
                }
                try
                {
                    byte[] buffer = new byte[65];
                    buffer[0] = 0;
                    for (int i = 0; i &lt; 64; i++)
                        buffer[i+1] = r[i];

                    hidDevice.Write(buffer, 0, 65);

                    return HID_RETURN.SUCCESS;
                }
                catch (IOException exception)
                {
                    System.Console.WriteLine(exception.Message);
                    System.Console.WriteLine(exception.StackTrace.ToString());

                    EventArgs ex = new EventArgs();
                    OnDeviceRemoved(ex);//发出设备移除消息
                    CloseDevice();
                    return HID_RETURN.NO_DEVICE_CONECTED;
                }

                }
                return HID_RETURN.WRITE_FAILD;
            }


            /// &lt;summary&gt;
            /// 获取所有连接的hid的设备路径
            /// &lt;/summary&gt;
            /// &lt;returns&gt;包含每个设备路径的字符串数组&lt;/returns&gt;
            public static void GetHidDeviceList(ref List&lt;string&gt; deviceList)
            {
                Guid hUSB = Guid.Empty;
                uint index = 0;

                deviceList.Clear();
                // 取得hid设备全局id
                HidD_GetHidGuid(ref hUSB);
                //取得一个包含所有HID接口信息集合的句柄
                IntPtr hidInfoSet = SetupDiGetClassDevs(ref hUSB, 0, IntPtr.Zero, DIGCF.DIGCF_PRESENT | DIGCF.DIGCF_DEVICEINTERFACE);
                if (hidInfoSet != IntPtr.Zero)
                {
                    SP_DEVICE_INTERFACE_DATA interfaceInfo = new SP_DEVICE_INTERFACE_DATA();
                    interfaceInfo.cbSize = Marshal.SizeOf(interfaceInfo);
                    //查询集合中每一个接口
                    for (index = 0; index &lt; MAX_USB_DEVICES; index++)
                    {
                        //得到第index个接口信息
                        if (SetupDiEnumDeviceInterfaces(hidInfoSet, IntPtr.Zero, ref hUSB, index, ref interfaceInfo))
                        {
                            int buffsize = 0;
                            // 取得接口详细信息:第一次读取错误,但可以取得信息缓冲区的大小
                            SetupDiGetDeviceInterfaceDetail(hidInfoSet, ref interfaceInfo, IntPtr.Zero, buffsize, ref buffsize, null);
                            //构建接收缓冲
                            IntPtr pDetail = Marshal.AllocHGlobal(buffsize);
                            SP_DEVICE_INTERFACE_DETAIL_DATA detail = new SP_DEVICE_INTERFACE_DETAIL_DATA();
                            detail.cbSize = Marshal.SizeOf(typeof(SP_DEVICE_INTERFACE_DETAIL_DATA));
                            Marshal.StructureToPtr(detail, pDetail, false);
                            if (SetupDiGetDeviceInterfaceDetail(hidInfoSet, ref interfaceInfo, pDetail, buffsize, ref buffsize, null))
                            {
                                deviceList.Add(Marshal.PtrToStringAuto((IntPtr)((int)pDetail + 4)));
                            }
                            Marshal.FreeHGlobal(pDetail);
                        }
                    }
                }
                SetupDiDestroyDeviceInfoList(hidInfoSet);
                //return deviceList.ToArray();
            }

            #region&lt;连接USB返回的结构体信息&gt;
            /// &lt;summary&gt;
            /// 连接USB返回的结构体信息
            /// &lt;/summary&gt;
            public enum HID_RETURN
            {
                SUCCESS = 0,
                NO_DEVICE_CONECTED,
                DEVICE_NOT_FIND,
                DEVICE_OPENED,
                WRITE_FAILD,
                READ_FAILD

            }
            #endregion


            // 以下是调用windows的API的函数
            /// &lt;summary&gt;
            /// The HidD_GetHidGuid routine returns the device interface GUID for HIDClass devices.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;HidGuid&quot;&gt;a caller-allocated GUID buffer that the routine uses to return the device interface GUID for HIDClass devices.&lt;/param&gt;
            [DllImport(&quot;hid.dll&quot;)]
            private static extern void HidD_GetHidGuid(ref Guid HidGuid);

            /// &lt;summary&gt;
            /// The SetupDiGetClassDevs function returns a handle to a device information set that contains requested device information elements for a local machine.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;ClassGuid&quot;&gt;GUID for a device setup class or a device interface class. &lt;/param&gt;
            /// &lt;param name=&quot;Enumerator&quot;&gt;A pointer to a NULL-terminated string that supplies the name of a PnP enumerator or a PnP device instance identifier. &lt;/param&gt;
            /// &lt;param name=&quot;HwndParent&quot;&gt;A handle of the top-level window to be used for a user interface&lt;/param&gt;
            /// &lt;param name=&quot;Flags&quot;&gt;A variable  that specifies control options that filter the device information elements that are added to the device information set. &lt;/param&gt;
            /// &lt;returns&gt;a handle to a device information set &lt;/returns&gt;
            [DllImport(&quot;setupapi.dll&quot;, SetLastError = true)]
            private static extern IntPtr SetupDiGetClassDevs(ref Guid ClassGuid, uint Enumerator, IntPtr HwndParent, DIGCF Flags);

            /// &lt;summary&gt;
            /// The SetupDiDestroyDeviceInfoList function deletes a device information set and frees all associated memory.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;DeviceInfoSet&quot;&gt;A handle to the device information set to delete.&lt;/param&gt;
            /// &lt;returns&gt;returns TRUE if it is successful. Otherwise, it returns FALSE &lt;/returns&gt;
            [DllImport(&quot;setupapi.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)]
            private static extern Boolean SetupDiDestroyDeviceInfoList(IntPtr deviceInfoSet);

            /// &lt;summary&gt;
            /// The SetupDiEnumDeviceInterfaces function enumerates the device interfaces that are contained in a device information set.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;deviceInfoSet&quot;&gt;A pointer to a device information set that contains the device interfaces for which to return information&lt;/param&gt;
            /// &lt;param name=&quot;deviceInfoData&quot;&gt;A pointer to an SP_DEVINFO_DATA structure that specifies a device information element in DeviceInfoSet&lt;/param&gt;
            /// &lt;param name=&quot;interfaceClassGuid&quot;&gt;a GUID that specifies the device interface class for the requested interface&lt;/param&gt;
            /// &lt;param name=&quot;memberIndex&quot;&gt;A zero-based index into the list of interfaces in the device information set&lt;/param&gt;
            /// &lt;param name=&quot;deviceInterfaceData&quot;&gt;a caller-allocated buffer that contains a completed SP_DEVICE_INTERFACE_DATA structure that identifies an interface that meets the search parameters&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            [DllImport(&quot;setupapi.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)]
            private static extern Boolean SetupDiEnumDeviceInterfaces(IntPtr deviceInfoSet, IntPtr deviceInfoData, ref Guid interfaceClassGuid, UInt32 memberIndex, ref SP_DEVICE_INTERFACE_DATA deviceInterfaceData);

            /// &lt;summary&gt;
            /// The SetupDiGetDeviceInterfaceDetail function returns details about a device interface.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;deviceInfoSet&quot;&gt;A pointer to the device information set that contains the interface for which to retrieve details&lt;/param&gt;
            /// &lt;param name=&quot;deviceInterfaceData&quot;&gt;A pointer to an SP_DEVICE_INTERFACE_DATA structure that specifies the interface in DeviceInfoSet for which to retrieve details&lt;/param&gt;
            /// &lt;param name=&quot;deviceInterfaceDetailData&quot;&gt;A pointer to an SP_DEVICE_INTERFACE_DETAIL_DATA structure to receive information about the specified interface&lt;/param&gt;
            /// &lt;param name=&quot;deviceInterfaceDetailDataSize&quot;&gt;The size of the DeviceInterfaceDetailData buffer&lt;/param&gt;
            /// &lt;param name=&quot;requiredSize&quot;&gt;A pointer to a variable that receives the required size of the DeviceInterfaceDetailData buffer&lt;/param&gt;
            /// &lt;param name=&quot;deviceInfoData&quot;&gt;A pointer buffer to receive information about the device that supports the requested interface&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            [DllImport(&quot;setupapi.dll&quot;, SetLastError = true, CharSet = CharSet.Auto)]
            private static extern bool SetupDiGetDeviceInterfaceDetail(IntPtr deviceInfoSet, ref SP_DEVICE_INTERFACE_DATA deviceInterfaceData, IntPtr deviceInterfaceDetailData, int deviceInterfaceDetailDataSize, ref int requiredSize, SP_DEVINFO_DATA deviceInfoData);

            /// &lt;summary&gt;
            /// The HidD_GetAttributes routine returns the attributes of a specified top-level collection.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;HidDeviceObject&quot;&gt;Specifies an open handle to a top-level collection&lt;/param&gt;
            /// &lt;param name=&quot;Attributes&quot;&gt;a caller-allocated HIDD_ATTRIBUTES structure that returns the attributes of the collection specified by HidDeviceObject&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            [DllImport(&quot;hid.dll&quot;)]
            private static extern Boolean HidD_GetAttributes(IntPtr hidDeviceObject, out HIDD_ATTRIBUTES attributes);
            /// &lt;summary&gt;
            /// The HidD_GetSerialNumberString routine returns the embedded string of a top-level collection that identifies the serial number of the collection&apos;s physical device.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;HidDeviceObject&quot;&gt;Specifies an open handle to a top-level collection&lt;/param&gt;
            /// &lt;param name=&quot;Buffer&quot;&gt;a caller-allocated buffer that the routine uses to return the requested serial number string&lt;/param&gt;
            /// &lt;param name=&quot;BufferLength&quot;&gt;Specifies the length, in bytes, of a caller-allocated buffer provided at Buffer&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            [DllImport(&quot;hid.dll&quot;)]
            private static extern Boolean HidD_GetSerialNumberString(IntPtr hidDeviceObject, IntPtr buffer, int bufferLength);

            /// &lt;summary&gt;
            /// The HidD_GetPreparsedData routine returns a top-level collection&apos;s preparsed data.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;hidDeviceObject&quot;&gt;Specifies an open handle to a top-level collection. &lt;/param&gt;
            /// &lt;param name=&quot;PreparsedData&quot;&gt;Pointer to the address of a routine-allocated buffer that contains a collection&apos;s preparsed data in a _HIDP_PREPARSED_DATA structure.&lt;/param&gt;
            /// &lt;returns&gt;HidD_GetPreparsedData returns TRUE if it succeeds; otherwise, it returns FALSE.&lt;/returns&gt;
            [DllImport(&quot;hid.dll&quot;)]
            private static extern Boolean HidD_GetPreparsedData(IntPtr hidDeviceObject, out IntPtr PreparsedData);

            [DllImport(&quot;hid.dll&quot;)]
            private static extern Boolean HidD_FreePreparsedData(IntPtr PreparsedData);

            [DllImport(&quot;hid.dll&quot;)]
            private static extern uint HidP_GetCaps(IntPtr PreparsedData, out HIDP_CAPS Capabilities);


            /// &lt;summary&gt;
            /// This function creates, opens, or truncates a file, COM port, device, service, or console.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;fileName&quot;&gt;a null-terminated string that specifies the name of the object&lt;/param&gt;
            /// &lt;param name=&quot;desiredAccess&quot;&gt;Type of access to the object&lt;/param&gt;
            /// &lt;param name=&quot;shareMode&quot;&gt;Share mode for object&lt;/param&gt;
            /// &lt;param name=&quot;securityAttributes&quot;&gt;Ignored; set to NULL&lt;/param&gt;
            /// &lt;param name=&quot;creationDisposition&quot;&gt;Action to take on files that exist, and which action to take when files do not exist&lt;/param&gt;
            /// &lt;param name=&quot;flagsAndAttributes&quot;&gt;File attributes and flags for the file&lt;/param&gt;
            /// &lt;param name=&quot;templateFile&quot;&gt;Ignored&lt;/param&gt;
            /// &lt;returns&gt;An open handle to the specified file indicates success&lt;/returns&gt;
            [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]
            private static extern IntPtr CreateFile(string fileName, uint desiredAccess, uint shareMode, uint securityAttributes, uint creationDisposition, uint flagsAndAttributes, uint templateFile);

            /// &lt;summary&gt;
            /// This function closes an open object handle.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;hObject&quot;&gt;Handle to an open object&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            [DllImport(&quot;kernel32.dll&quot;)]
            private static extern int CloseHandle(IntPtr hObject);

            /// &lt;summary&gt;
            /// This function reads data from a file, starting at the position indicated by the file pointer.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;file&quot;&gt;Handle to the file to be read&lt;/param&gt;
            /// &lt;param name=&quot;buffer&quot;&gt;Pointer to the buffer that receives the data read from the file &lt;/param&gt;
            /// &lt;param name=&quot;numberOfBytesToRead&quot;&gt;Number of bytes to be read from the file&lt;/param&gt;
            /// &lt;param name=&quot;numberOfBytesRead&quot;&gt;Pointer to the number of bytes read&lt;/param&gt;
            /// &lt;param name=&quot;lpOverlapped&quot;&gt;Unsupported; set to NULL&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            [DllImport(&quot;Kernel32.dll&quot;, SetLastError = true)]
            private static extern bool ReadFile(IntPtr file, byte[] buffer, uint numberOfBytesToRead, out uint numberOfBytesRead, IntPtr lpOverlapped);

            /// &lt;summary&gt;
            ///  This function writes data to a file
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;file&quot;&gt;Handle to the file to be written to&lt;/param&gt;
            /// &lt;param name=&quot;buffer&quot;&gt;Pointer to the buffer containing the data to write to the file&lt;/param&gt;
            /// &lt;param name=&quot;numberOfBytesToWrite&quot;&gt;Number of bytes to write to the file&lt;/param&gt;
            /// &lt;param name=&quot;numberOfBytesWritten&quot;&gt;Pointer to the number of bytes written by this function call&lt;/param&gt;
            /// &lt;param name=&quot;lpOverlapped&quot;&gt;Unsupported; set to NULL&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            [DllImport(&quot;Kernel32.dll&quot;, SetLastError = true)]
            private static extern bool WriteFile(IntPtr file, byte[] buffer, uint numberOfBytesToWrite, out uint numberOfBytesWritten, IntPtr lpOverlapped);

            /// &lt;summary&gt;
            /// Registers the device or type of device for which a window will receive notifications
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;recipient&quot;&gt;A handle to the window or service that will receive device events for the devices specified in the NotificationFilter parameter&lt;/param&gt;
            /// &lt;param name=&quot;notificationFilter&quot;&gt;A pointer to a block of data that specifies the type of device for which notifications should be sent&lt;/param&gt;
            /// &lt;param name=&quot;flags&quot;&gt;A Flags that specify the handle type&lt;/param&gt;
            /// &lt;returns&gt;If the function succeeds, the return value is a device notification handle&lt;/returns&gt;
            [DllImport(&quot;User32.dll&quot;, SetLastError = true)]
            private static extern IntPtr RegisterDeviceNotification(IntPtr recipient, IntPtr notificationFilter, int flags);

            /// &lt;summary&gt;
            /// Closes the specified device notification handle.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;handle&quot;&gt;Device notification handle returned by the RegisterDeviceNotification function&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            [DllImport(&quot;user32.dll&quot;, SetLastError = true)]
            private static extern bool UnregisterDeviceNotification(IntPtr handle);
        }
        #region
        /// &lt;summary&gt;
        /// SP_DEVICE_INTERFACE_DATA structure defines a device interface in a device information set.
        /// &lt;/summary&gt;
        public struct SP_DEVICE_INTERFACE_DATA
        {
            public int cbSize;
            public Guid interfaceClassGuid;
            public int flags;
            public int reserved;
        }

        /// &lt;summary&gt;
        /// SP_DEVICE_INTERFACE_DETAIL_DATA structure contains the path for a device interface.
        /// &lt;/summary&gt;
        [StructLayout(LayoutKind.Sequential, Pack = 2)]
        internal struct SP_DEVICE_INTERFACE_DETAIL_DATA
        {
            internal int cbSize;
            internal short devicePath;
        }

        /// &lt;summary&gt;
        /// SP_DEVINFO_DATA structure defines a device instance that is a member of a device information set.
        /// &lt;/summary&gt;
        [StructLayout(LayoutKind.Sequential)]
        public class SP_DEVINFO_DATA
        {
            public int cbSize = Marshal.SizeOf(typeof(SP_DEVINFO_DATA));
            public Guid classGuid = Guid.Empty; // temp
            public int devInst = 0; // dumy
            public int reserved = 0;
        }
        /// &lt;summary&gt;
        /// Flags controlling what is included in the device information set built by SetupDiGetClassDevs
        /// &lt;/summary&gt;
        public enum DIGCF
        {
            DIGCF_DEFAULT = 0x00000001, // only valid with DIGCF_DEVICEINTERFACE
            DIGCF_PRESENT = 0x00000002,
            DIGCF_ALLCLASSES = 0x00000004,
            DIGCF_PROFILE = 0x00000008,
            DIGCF_DEVICEINTERFACE = 0x00000010
        }
        /// &lt;summary&gt;
        /// The HIDD_ATTRIBUTES structure contains vendor information about a HIDClass device
        /// &lt;/summary&gt;
        public struct HIDD_ATTRIBUTES
        {
            public int Size;
            public ushort VendorID;
            public ushort ProductID;
            public ushort VersionNumber;
        }

        public struct HIDP_CAPS
        {
            public ushort Usage;
            public ushort UsagePage;
            public ushort InputReportByteLength;
            public ushort OutputReportByteLength;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 17)]
            public ushort[] Reserved;
            public ushort NumberLinkCollectionNodes;
            public ushort NumberInputButtonCaps;
            public ushort NumberInputValueCaps;
            public ushort NumberInputDataIndices;
            public ushort NumberOutputButtonCaps;
            public ushort NumberOutputValueCaps;
            public ushort NumberOutputDataIndices;
            public ushort NumberFeatureButtonCaps;
            public ushort NumberFeatureValueCaps;
            public ushort NumberFeatureDataIndices;
        }
        /// &lt;summary&gt;
        /// Type of access to the object.
        ///&lt;/summary&gt;
        static class DESIREDACCESS
        {
            public const uint GENERIC_READ = 0x80000000;
            public const uint GENERIC_WRITE = 0x40000000;
            public const uint GENERIC_EXECUTE = 0x20000000;
            public const uint GENERIC_ALL = 0x10000000;
        }
        /// &lt;summary&gt;
        /// Action to take on files that exist, and which action to take when files do not exist.
        /// &lt;/summary&gt;
        static class CREATIONDISPOSITION
        {
            public const uint CREATE_NEW = 1;
            public const uint CREATE_ALWAYS = 2;
            public const uint OPEN_EXISTING = 3;
            public const uint OPEN_ALWAYS = 4;
            public const uint TRUNCATE_EXISTING = 5;
        }
        /// &lt;summary&gt;
        /// File attributes and flags for the file.
        /// &lt;/summary&gt;
        static class FLAGSANDATTRIBUTES
        {
            public const uint FILE_FLAG_WRITE_THROUGH = 0x80000000;
            public const uint FILE_FLAG_OVERLAPPED = 0x40000000;
            public const uint FILE_FLAG_NO_BUFFERING = 0x20000000;
            public const uint FILE_FLAG_RANDOM_ACCESS = 0x10000000;
            public const uint FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000;
            public const uint FILE_FLAG_DELETE_ON_CLOSE = 0x04000000;
            public const uint FILE_FLAG_BACKUP_SEMANTICS = 0x02000000;
            public const uint FILE_FLAG_POSIX_SEMANTICS = 0x01000000;
            public const uint FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000;
            public const uint FILE_FLAG_OPEN_NO_RECALL = 0x00100000;
            public const uint FILE_FLAG_FIRST_PIPE_INSTANCE = 0x00080000;
        }
        /// &lt;summary&gt;
        /// Serves as a standard header for information related to a device event reported through the WM_DEVICECHANGE message.
        /// &lt;/summary&gt;
        [StructLayout(LayoutKind.Sequential)]
        public struct DEV_BROADCAST_HDR
        {
            public int dbcc_size;
            public int dbcc_devicetype;
            public int dbcc_reserved;
        }
        /// &lt;summary&gt;
        /// Contains information about a class of devices
        /// &lt;/summary&gt;
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct DEV_BROADCAST_DEVICEINTERFACE
        {
            public int dbcc_size;
            public int dbcc_devicetype;
            public int dbcc_reserved;
            public Guid dbcc_classguid;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 255)]
            public string dbcc_name;
        }
        #endregion

}
</code></pre><p>HID类是最底层的，他直接使用了window API，这是一个C++的库，所以不能直接引用，需要使用前文提到的DllImport来导入并翻译。</p>
<p>HIDInterface类:</p>
<pre><code>using System;
using System.Text;
using System.Threading;
using System.IO;
using System.ComponentModel;

namespace ReaderCSharp
{
    public class HIDInterface : IDisposable
    {

        public enum MessagesType
        {
            Message,
            Error
        }

        public struct ReusltString
        {
            public bool Result;
            public string message;
        }

        public struct HidDevice
        {
            public UInt16 vID;
            public UInt16 pID;
            public string serial;
        }
        HidDevice lowHidDevice = new HidDevice();

        public delegate void DelegateDataReceived(object sender, byte[] data);
        public DelegateDataReceived DataReceived;

        public delegate void DelegateStatusConnected(object sender, bool isConnect);
        public DelegateStatusConnected StatusConnected;

        public bool bConnected = false;


        public Hid oSp = new Hid();
        private static HIDInterface m_oInstance;

        public struct TagInfo
        {
            public string AntennaPort;
            public string EPC;
        }

        public HIDInterface()
        {
            m_oInstance = this;
            oSp.DataReceived = HidDataReceived;
            oSp.DeviceRemoved = HidDeviceRemoved;
        }

        protected virtual void RaiseEventConnectedState(bool isConnect)
        {
            if (null != StatusConnected) StatusConnected(this, isConnect);
        }

        protected virtual void RaiseEventDataReceived(byte[] buf)
        {
            if (null != DataReceived) DataReceived(this, buf);
        }

        public void AutoConnect(HidDevice hidDevice)
        {
            lowHidDevice = hidDevice;
            ContinueConnectFlag = true;

            ReadWriteThread.DoWork += ReadWriteThread_DoWork;
            ReadWriteThread.WorkerSupportsCancellation = true;
            ReadWriteThread.RunWorkerAsync();   //Recommend performing USB read/write operations in a separate thread.  Otherwise,

        }

        public void StopAutoConnect()
        {
            try
            {
                ContinueConnectFlag = false;
                Dispose();
            }
            catch
            {

            }
        }

        ~HIDInterface()
        {
            Dispose();
        }

        public bool Connect(HidDevice hidDevice)
        {
            ReusltString result = new ReusltString();

            Hid.HID_RETURN hdrtn = oSp.OpenDevice(hidDevice.vID, hidDevice.pID, hidDevice.serial);

            if (hdrtn == Hid.HID_RETURN.SUCCESS)
            {

                bConnected = true;

                #region 消息通知
                result.Result = true;
                result.message = &quot;Connect Success!&quot;;
                RaiseEventConnectedState(result.Result);
                #endregion


                return true;
            }

            bConnected = false;

            #region 消息通知
            result.Result = false;
            result.message = &quot;Device Connect Error&quot;;
            RaiseEventConnectedState(result.Result);

            #endregion
            return false;
        }


        public bool Send(byte[] byData)
        {
            byte[] sendtemp = new byte[64];
            Array.Copy(byData, 0, sendtemp, 0, byData.Length&gt;64?64:byData.Length);

            Hid.HID_RETURN hdrtn = oSp.Write(sendtemp);

            if (hdrtn != Hid.HID_RETURN.SUCCESS)
            {
                return false;
            }

            return true;
        }

        public bool Send(string strData)
        {
            //获得报文的编码字节
            byte[] data = Encoding.Unicode.GetBytes(strData);
            return Send(data);
        }

        public bool Read()
        {
            if (bConnected == false) {
                return false;
            }
            oSp.ReadCMD();
            return true;
        }


        public void DisConnect()
        {
            bConnected = false;

            Thread.Sleep(200);
            if (oSp != null)
            {
                oSp.CloseDevice();
            }
        }


        void HidDeviceRemoved(object sender, EventArgs e)
        {
            bConnected = false;
            #region 消息通知
            ReusltString result = new ReusltString();
            result.Result = false;
            result.message = &quot;Device Remove&quot;;
            RaiseEventConnectedState(result.Result);
            #endregion
            if (oSp != null)
            {
                oSp.CloseDevice();
            }

        }

        public void HidDataReceived(object sender, byte[] e)
        {

            try
            {
                //第一个字节为数据长度，因为Device 的HID数据固定长度为64字节，取有效数据
                int length = 64;
                byte[] buf = new byte[length];
                Array.Copy(e, 1, buf, 0, length);

                //推送数据
                RaiseEventDataReceived(buf);
            }
            catch
            {
                #region 消息通知
                ReusltString result = new ReusltString();
                result.Result = false;
                result.message = &quot;Receive Error&quot;;
                RaiseEventConnectedState(result.Result);
                #endregion
            }

        }

        public void Dispose()
        {
            try
            {
                this.DisConnect();
                oSp.DataReceived -= HidDataReceived;
                oSp.DeviceRemoved -= HidDeviceRemoved;
                ReadWriteThread.DoWork -= ReadWriteThread_DoWork;
                ReadWriteThread.CancelAsync();
                ReadWriteThread.Dispose();
            }
            catch
            { }
        }

        Boolean ContinueConnectFlag = true;

    }
}
</code></pre><p>使用起来非常方便，只要使用HIDInterface类就可以了，而且自动重连的功能还保留着。</p>
<p>使用方法：</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace ReaderCSharp
{
    public class TagReaderManager
    {

        private static TagReaderManager shared;


        struct connectStatusStruct
        {
            public bool preStatus;
            public bool curStatus;
        }

        connectStatusStruct connectStatus = new connectStatusStruct();

        //推送连接状态信息
        public delegate void isConnectedDelegate(bool isConnected);
        public isConnectedDelegate isConnectedFunc;


        //推送接收数据信息
        public delegate void PushReceiveDataDele(byte[] datas);
        public PushReceiveDataDele pushReceiveData;


        private byte[] receivedBuffer = null;

        private HIDInterface hid;

        public static TagReaderManager sharedManager()
        {
            if (shared == null) {
                shared = new TagReaderManager();
            }
            return shared;
        }

        private TagReaderManager()
        {
            hid = new HIDInterface();
        }

        private bool sendingData(byte[] data) {
            return hid.Send(data);
        }

        bool receiveData()
        {
            return hid.Read();
        }

        public bool connectDevice()
        {

            hid.StatusConnected = StatusConnected;
            hid.DataReceived = DataReceived;

            HIDInterface.HidDevice hidDevice = new HIDInterface.HidDevice();
            hidDevice.vID = 0x0483;
            hidDevice.pID = 0x5750;
            hidDevice.serial = &quot;&quot;;
            hid.AutoConnect(hidDevice);
            connectionStatus = false;

            return true;
        }

        //接受到数据
        public void DataReceived(object sender, byte[] e)
        {
            if (e != null) {
                Console.WriteLine(BitConverter.ToString(e));
                receivedBuffer = e;
            }
        }

        //状态改变接收
        public void StatusConnected(object sender, bool isConnect)
        {
            connectStatus.curStatus = isConnect;
            if (connectStatus.curStatus == connectStatus.preStatus)  //connect
                return;
            connectStatus.preStatus = connectStatus.curStatus;

            if (connectStatus.curStatus)
            {
                connectionStatus = true;
                System.Console.WriteLine(&quot;hid connected!&quot;);
                //ReportMessage(MessagesType.Message, &quot;连接成功&quot;);
            }
            else //disconnect
            {
                connectionStatus = false;
                System.Console.WriteLine(&quot;hid disconnected!&quot;);
                //ReportMessage(MessagesType.Error, &quot;无法连接&quot;);
            }
        }
        public bool connectionStatus{ set; get; }

    }
}
</code></pre><p>发送就是发送，接收的话，通过一个flag和receivedBuffer来确定，很好理解～</p>
<p>HID的代码和原作者的代码相比较有一些修改，OpenDevice这个函数中CreateFile()函数的参数有些不同，原作者是禁止其他进程共享HID描述文件的。然而这样一来我们的程序就无法成功的建立文件，并进行通信。<br>所以我怀疑可能是操作系统版本不同，所以系统对于共享权限有了不同的限制吧～</p>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>这次通过这个项目，感觉自己对软硬件通信又长进了不少。将这几个HID相关的东西做了封装之后，其他同学调用起来操控读取器就方便多了，而且最重要的是，这个库完完全全是.NET的库，所以他们可以用wpf或者winform来写界面了，可以说是非常爽了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/study/20180717-hid-over-usb.html" data-id="ckl153wbf0043zxij57xkgu0j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/working/" rel="tag">Working</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-g3plc-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/study/20180712-g3plc-2.html" class="article-date">
  <time datetime="2018-07-12T00:46:50.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/study/">学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/study/20180712-g3plc-2.html">G3PLC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>最近实在是忙爆了，终于有时间来更新两篇文章了！</p>
<p>去年教研室的G3PLC项目，终于在我们加班加点后，赶出来了。</p>
<p>我们负责在原有功能上增加路由功能，也就是LOADng。</p>
<h3 id="Route-Table"><a href="#Route-Table" class="headerlink" title="Route Table"></a>Route Table</h3><p>LOADng是一个轻量级的协议，传输的数据都是必须要的最小量。</p>
<p>比如，路由表里存的每一条都只有去目标节点的下一跳。发送也是，将数据发送给下一跳后，便假装自己已经发送完毕了。</p>
<p>每次单播数据都需要ack确认，如果多次重发没有获得ack，那便意味着发送不成功，该条路线出现了故障，于是便开启路由修复，修复成功后，再次发送。</p>
<p>感觉每一个操作都很简单。</p>
<h3 id="Blacklist"><a href="#Blacklist" class="headerlink" title="Blacklist"></a>Blacklist</h3><p>黑名单是LOADng用来进一步降低消耗的一个措施。</p>
<p>在电力线路中通信，经过实验，有时候通信并不是双向的。有时候真的只能发出去，但是收不到。</p>
<p>所以有了blacklist之后，明明收到了一条消息，但是发现他在黑名单中，就不会直接原路发送应答，而是会选另一条路去应答。</p>
<h3 id="Route-Error"><a href="#Route-Error" class="headerlink" title="Route Error"></a>Route Error</h3><p>路由错误，这里有个坑儿。一开始我觉得每一个错误路由都可以删除其相关的路由。</p>
<p>比如，我收到了一条A结点不可达的rerr信息，那么按理说我应该把所有需要路过A的路由都删掉。可是在日本测试中，他们却认为只要删除收到的rerr即可。</p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>时隔差不多一个月才想起写这一篇。剩下的内容还得再温习一下，再写～</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/study/20180712-g3plc-2.html" data-id="ckl153wba003uzxijwkmlgfc3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/working/" rel="tag">Working</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-data-struct-alignment" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/programming/20180613-data-struct-alignment.html" class="article-date">
  <time datetime="2018-06-13T14:06:42.000Z" itemprop="datePublished">2018-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/programming/20180613-data-struct-alignment.html">字节对齐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>去年我们接手了一个G3PLC的项目，这也算是首次正正规规的做一次嵌入式了，也是我第一次在自己的电脑上安装并使用keil，有点小兴奋。</p>
<p>一开始我们心里还是蛮害怕的，因为协议很多，我们嵌入式基础很弱，一直担心最后这个项目无法完成。不过，到了今年6月，我们竟然真的写完了！</p>
<p><code>俗话</code>说得好，写程序花20%的时间，调试花80%的时间~ 当然这是他们嵌入式行业的俗话~</p>
<p>于是我们开始了紧张的调试，一开始还蛮顺利，遇到了问题基本上可以非常快的定位到问题点，然后也可以非常快的解决。</p>
<p>直到…</p>
<h3 id="StackTrace"><a href="#StackTrace" class="headerlink" title="StackTrace"></a>StackTrace</h3><p>先来看两个结构体</p>
<p>adp.h:</p>
<pre><code>typedef struct _ROUTINGTABLE_
{
    uSHORT    DestinationAddress; //16
    uSHORT    NextHopAddress; //16
    uSHORT    RouteCost; //16
    unsigned    HopCount:4;
    unsigned    WeakLinkCount:4;
    uSHORT    ValidTime;//16
}_ROUTINGTABLE,*_pROUTINGTABLE;
</code></pre><p>mmu.h:</p>
<pre><code>typedef struct _ROUTINGTABLEITEM_
{
    uSHORT    destination; //2
    uSHORT nextHop; //2
    uSHORT cost; //2
    unsigned hopCount:4; //0.5
    unsigned weakLinkCount:4; //0.5
    uSHORT    ValidTime; //2
}_ROUTINGTABLEITEM, *_pROUTINGTABLEITEM;
</code></pre><p>这两个结构体除了名字不一样，别的都是一样的，每个变量的位置，变量的类型，所以我们觉得他们就是<code>一样的</code></p>
<p>然后就出现了奇怪的现象～</p>
<p>我们设置了ValidTime之后，数据变了，变得我们不认识了!</p>
<p>我们上一行把ValidTime设置成300(<code>0x012c</code>)之后下一行用16进制打印强制转换另一个类型的ValidTime，却变成了<code>0x2c00</code></p>
<p>我们上一行把ValidTime设置成30(<code>0x001e</code>)之后下一行用16进制打印强制转换另一个类型的ValidTime，却变成了<code>0x1e00</code></p>
<p>是编译器欺负人？还是单片机欺负人？</p>
<p>按理说两个类型是完全一样的，那么我传入的指针，被强制转换之后，每个变量所对应的地址也是一样的，那内容应该也是一样的呀</p>
<h3 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h3><p>折腾了很长时间，最后我就强行把类型统一了，使用同一个struct。竟然就好了！</p>
<p>于是我们发现在adp.h定义这一串struct之前有 #pragma pack(1)</p>
<p>他的功能是字节对齐，1就代表着1字节对齐。</p>
<p>在Keil官网上，对pack这个预编译函数有<a href="http://www.keil.com/support/man/docs/ARMCC/armcc_chr1359124990875.htm" target="_blank" rel="noopener">介绍</a>，<br>编译器默认是8字节对齐，所以只要不屑pack(1)，那就是8字节对齐的。官网这里的demo我觉得有点问题，所以我就用另一个例子来说明。</p>
<h4 id="以下内容夹杂猜想"><a href="#以下内容夹杂猜想" class="headerlink" title="以下内容夹杂猜想"></a>以下内容夹杂猜想</h4><p>adp.h:</p>
<pre><code>#pragma pack(1)
......

typedef struct _ROUTINGTABLE_
{
    uSHORT    DestinationAddress; //16
    uSHORT    NextHopAddress; //16
    uSHORT    RouteCost; //16
    unsigned    HopCount:4;
    unsigned    WeakLinkCount:4;
    uSHORT    ValidTime;//16
}_ROUTINGTABLE,*_pROUTINGTABLE;
</code></pre><p>这里按照1个字节对齐，在内存里就是这样的</p>
<pre><code>|-----------0-----------|
 -----------------------
|     Destination_H     |
|     Destination_L     |
|    NextHopAddress_H   |
|    NextHopAddress_L   |
|      RouteCost_H      |
|      RouteCost_L      |
|HopCount,WeakLinkCount |
|      ValidTime_H      |
|      ValidTime_L      |
</code></pre><p>sizeof(_ROUTINGTABLE)==9，这个应该是理想情况，但是如果没有pack(1)</p>
<p>mmu.h:</p>
<pre><code>typedef struct _ROUTINGTABLEITEM_
{
    uSHORT    destination; //2
    uSHORT nextHop; //2
    uSHORT cost; //2
    unsigned hopCount:4; //0.5
    unsigned weakLinkCount:4; //0.5
    uSHORT    ValidTime; //2
}_ROUTINGTABLEITEM, *_pROUTINGTABLEITEM;
</code></pre><p>这里我觉得应该是按照2个字节对齐(虽然官网说的是8),在内存里就是这样的</p>
<pre><code>|     0    |    1    |
 --------------------
|   dstH   |  dstL   |
|   NextH  |  NextL  |
|   cstH   |  cstL   |
|hopC\weakC|    *    |
|  ValTimH | ValTimL |
</code></pre><p>sizeof(_ROUTINGTABLEITEM)==10，于是字节错位了!</p>
<p>我们使用_ROUTINGTABLEITEM这个结构体对validTime赋值，会操作结构体内存的8、9位字节</p>
<p>使用错误案例validTime=300(0x012c),short在内存中存放为0x2c,0x01(倒着的~)</p>
<p>于是结构体为dstH,dstL,NxtH,NxtL,cstH,cstL,hop,weak,0x00,0x2c,0x01</p>
<p>但是使用_ROUTINGTABLE这个结构体去读取validTime的时候，会读取结构体内存的7、8位字节</p>
<p>也就是dst[7]=00,dst[8]=0x2c,于是validTime变成了0x2c00，超大的数字!</p>
<h3 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h3><p>这里bit field对齐夹杂了我的部分猜测，因为我查了很多很多很多资料，也没有找到比特操作的明确说明～</p>
<p>所以我就参考了这个<a href="http://www.catb.org/esr/structure-packing/" target="_blank" rel="noopener">牛逼的网页</a></p>
<p>假设bit是自动按序排列的，只要几个bit field大小总和小于等于一个字节，就使用一个字节空间，<br>而如果超过一个字节，那就需要把超的哪个bit field赶到下一个字节中去。</p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>所以嵌入式是真的难啊！</p>
<p>我们这几天的调试还遇到了一些坑，过几天总结一下再来说说～</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/programming/20180613-data-struct-alignment.html" data-id="ckl153wb2003dzxijlylgb8gd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/working/" rel="tag">Working</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-bluetooth-shit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexosource/programming/20180607-android-bluetooth-shit.html" class="article-date">
  <time datetime="2018-06-07T01:25:21.000Z" itemprop="datePublished">2018-06-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/hexosource/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexosource/programming/20180607-android-bluetooth-shit.html">Android 蓝牙之坑(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>翻了翻之前的post，发现写了很多关于android蓝牙的东西，每一次都是在不断的摸索，在进步。今天当然也不例外啦～不过我感觉在上一篇post之后，Android的<br>BLE应该算是摸的透了吧。直到前天～</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>零零柒水壶架在配对的时候过程比较复杂，在绑定的时候会涉及到蓝牙操作，也会涉及到网络操作。我们的蓝牙在连接上之后也会需要一个认证才能通信。这段时间一帮德国用户反映，Android客户端在绑定的时候老是出幺蛾子。<br>在折腾了两周无果之后，我终于忍不住了，为什么我本地百测百通过的app，到了他们手里就百测百不通过了呢？于是发了一个跟踪所有log的版本给他们。我倒是要看看，出了啥毛病。</p>
<h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>其实跟踪还是蛮方便的，这真的多亏了leancloud。</p>
<p>我做了一个新的Log类</p>
<pre><code>import android.os.Build;

import com.avos.avoscloud.AVException;
import com.avos.avoscloud.AVObject;
import com.avos.avoscloud.SaveCallback;
import com.viking.locator.model.CarrierRecord;

public class Log {

    public static void apn(CarrierRecord carriar){
        if (carriar.isManaually()){
            AVObject debug = new AVObject(&quot;APN&quot;);
            debug.put(&quot;model&quot;, android.os.Build.MODEL);
            debug.put(&quot;brand&quot;, android.os.Build.BRAND);
            debug.put(&quot;version&quot;, Build.VERSION.RELEASE);
            debug.put(&quot;address&quot;,carriar.getApnAddress());
            debug.put(&quot;carriar&quot;,carriar.getCarrierName());
            debug.put(&quot;password&quot;,carriar.getPassword());
            debug.put(&quot;username&quot;,carriar.getUsername());
            debug.put(&quot;country&quot;,carriar.getCountryCode());
            debug.saveInBackground(new SaveCallback() {
                @Override
                public void done(AVException e) {
                }
            });
        }
    }

    public static void d(Object tag, String msg) {
        com.litesuits.android.log.Log.d(tag, msg);
//        debug(tag, msg);
    }

    public static void e(Object tag, String msg) {
        com.litesuits.android.log.Log.e(tag, msg);
//        debug(tag, msg);
    }

    public static void d(Object tag,String msg,boolean upload){
        com.litesuits.android.log.Log.d(tag, msg);
        if (upload){
            upload(tag,msg);
        }
    }

    public static void e(Object tag,String msg,boolean upload){
        com.litesuits.android.log.Log.e(tag, msg);
        if (upload){
            upload(tag,msg);
        }
    }

    private static void debug(Object tag,String msg){
        AVObject debug = new AVObject(&quot;DEBUG&quot;);
        debug.put(&quot;tag&quot;, tag.toString());
        debug.put(&quot;msg&quot;, msg);
        debug.put(&quot;model&quot;, android.os.Build.MODEL);
        debug.put(&quot;brand&quot;, android.os.Build.BRAND);
        debug.put(&quot;version&quot;, Build.VERSION.RELEASE);
        debug.saveInBackground(new SaveCallback() {
            @Override
            public void done(AVException e) {
            }
        });
    }

    private static void upload(Object tag, String msg) {
        AVObject debug = new AVObject(&quot;LOG&quot;);
        debug.put(&quot;tag&quot;, tag.toString());
        debug.put(&quot;msg&quot;, msg);
        debug.put(&quot;model&quot;, android.os.Build.MODEL);
        debug.put(&quot;brand&quot;, android.os.Build.BRAND);
        debug.put(&quot;version&quot;, Build.VERSION.RELEASE);
        debug.saveInBackground(new SaveCallback() {
            @Override
            public void done(AVException e) {
            }
        });
    }
}
</code></pre><p>这样只要替换之前的Log，就可以把log时候的tag，msg，包括手机型号什么的都打印上去。</p>
<p>而且leancloud的网页端查看起来也蛮方便～</p>
<h3 id="status-22"><a href="#status-22" class="headerlink" title="status=22"></a>status=22</h3><p>按照正规流程，连上蓝牙发发数据，网络同步，整个过程大概就2-3秒。所以当初的当初，在设计这个配对的时候我压根就没有考虑过，蓝牙会在这短短短短的几秒钟断开。<br>因为数据量也很小，时间也很短，因此状态基也没有涉及到蓝牙断开的状态。反而设计了很多蓝牙读写失败的没用状态～</p>
<p>而恰恰就是这2-3秒，有的Android手机还真的要给你断个线～</p>
<p>从google官方文档看，在BluetoothGattCallback里面的onConnectionStateChange接口里面可以得到蓝牙GATT的连接状态。而且上一篇post也列举了4种可能出现的状态。</p>
<p>可是，这4种并不是全部状态！</p>
<p>我发现在德国用户的手机上出现了status=22,new_status=DISCONNECTED这样的状态，官方文档只说了status为GATT_SUCCESS(0),GATT_FAILURE(257)。那这个22是啥状态呢！</p>
<p><code>你猜!</code></p>
<p>感觉google你是在玩我～</p>
<p>所以上一篇post里的蓝牙被动断开应该不仅仅是status=GATT_FAILURE,new_status=DISCONNECTED。应该是status不为GATT_SUCCESS,new_status为DISCONNECTED的都算！鬼知道status还会出现什么值呢～经过google，没有正确答案，或许这就是玄学吧！</p>
<p>当然，在google的时候，还看到有兄弟遇到了status=8的情况，他们也是一脸懵逼～</p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>所以我打算开一个系列，专门用来写Android BLE的坑！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vikingwarlock.gitee.io/hexosource/programming/20180607-android-bluetooth-shit.html" data-id="ckl153wal002azxijek4rse93" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/hexosource/tags/android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/hexosource/page/2/">&amp;laquo; __(&#39;prev&#39;)</a><a class="page-number" href="/hexosource/">1</a><a class="page-number" href="/hexosource/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/hexosource/page/4/">4</a><a class="page-number" href="/hexosource/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/hexosource/page/9/">9</a><a class="extend next" rel="next" href="/hexosource/page/4/">__(&#39;next&#39;) &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/hexosource/categories/book/">书记</a></li><li class="category-list-item"><a class="category-list-link" href="/hexosource/categories/wtf/">什么鬼</a></li><li class="category-list-item"><a class="category-list-link" href="/hexosource/categories/study/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/hexosource/categories/life/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/hexosource/categories/programming/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/hexosource/categories/hack/">黑科技</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/arduino/" rel="tag">Arduino</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/ide/" rel="tag">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/mini/" rel="tag">Mini</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/working/" rel="tag">Working</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/ios/" rel="tag">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/yearly/" rel="tag">年记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/unknow/" rel="tag">怎么算呢</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/diary/" rel="tag">日记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/soup/" rel="tag">汤</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/play/" rel="tag">玩玩的</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/note/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/ble/" rel="tag">蓝牙</a></li><li class="tag-list-item"><a class="tag-list-link" href="/hexosource/tags/Hack/" rel="tag">黑</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/hexosource/tags/android/" style="font-size: 15.71px;">Android</a> <a href="/hexosource/tags/arduino/" style="font-size: 10px;">Arduino</a> <a href="/hexosource/tags/ide/" style="font-size: 10px;">IDE</a> <a href="/hexosource/tags/mini/" style="font-size: 10px;">Mini</a> <a href="/hexosource/tags/python/" style="font-size: 15.71px;">Python</a> <a href="/hexosource/tags/web/" style="font-size: 10px;">Web</a> <a href="/hexosource/tags/working/" style="font-size: 17.14px;">Working</a> <a href="/hexosource/tags/ios/" style="font-size: 17.14px;">iOS</a> <a href="/hexosource/tags/yearly/" style="font-size: 18.57px;">年记</a> <a href="/hexosource/tags/unknow/" style="font-size: 14.29px;">怎么算呢</a> <a href="/hexosource/tags/diary/" style="font-size: 20px;">日记</a> <a href="/hexosource/tags/soup/" style="font-size: 10px;">汤</a> <a href="/hexosource/tags/play/" style="font-size: 11.43px;">玩玩的</a> <a href="/hexosource/tags/note/" style="font-size: 12.86px;">笔记</a> <a href="/hexosource/tags/ble/" style="font-size: 14.29px;">蓝牙</a> <a href="/hexosource/tags/Hack/" style="font-size: 11.43px;">黑</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2012/10/">十月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2012/09/">九月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2012/01/">一月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2011/01/">一月 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexosource/archives/2010/01/">一月 2010</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/hexosource/life/20220206-2022-noname.html">2021 roll king</a>
          </li>
        
          <li>
            <a href="/hexosource/life/20210211-2021-what-a-tough-year.html">重启2020</a>
          </li>
        
          <li>
            <a href="/hexosource/life/20200121-2020-enbrace-change.html">2020唯一不变的是变化</a>
          </li>
        
          <li>
            <a href="/hexosource/uncategorized/20191027-digital-signature-and-verification.html">数字签名于验签</a>
          </li>
        
          <li>
            <a href="/hexosource/uncategorized/20191027-xml-validation.html">XML格式校验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Viking Warlock<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/hexosource/" class="mobile-nav-link">Home</a>
  
    <a href="/hexosource/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/hexosource/fancybox/jquery.fancybox.css">

  
<script src="/hexosource/fancybox/jquery.fancybox.pack.js"></script>




<script src="/hexosource/js/script.js"></script>


  </div>
</body>
</html>